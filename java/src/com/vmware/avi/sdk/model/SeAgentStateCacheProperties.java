/*
 * Avi avi_global_spec Object API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 20.1.1
 * Contact: support@avinetworks.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.vmware.avi.sdk.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
/**
 * SeAgentStateCacheProperties
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-12T12:27:26.755+05:30[Asia/Kolkata]")
public class SeAgentStateCacheProperties {
  @JsonProperty("sc_batch_buffer_flush_limit")
  private Integer scBatchBufferFlushLimit = 300;

  @JsonProperty("sc_shard_cleanup_max_time")
  private Integer scShardCleanupMaxTime = 900;

  @JsonProperty("sc_state_ring_batch_dequeue_limit")
  private Integer scStateRingBatchDequeueLimit = 300;

  @JsonProperty("sc_states_flush_interval")
  private Integer scStatesFlushInterval = 100;

  @JsonProperty("sc_stream_check_interval")
  private Integer scStreamCheckInterval = 5000;

  @JsonProperty("sc_thread_q_batch_dequeue_limit")
  private Integer scThreadQBatchDequeueLimit = 100;

  @JsonProperty("sc_thread_q_max_size")
  private Integer scThreadQMaxSize = 4096;

  @JsonProperty("sc_thread_sleep_interval")
  private Integer scThreadSleepInterval = 10;

  public SeAgentStateCacheProperties scBatchBufferFlushLimit(Integer scBatchBufferFlushLimit) {
    this.scBatchBufferFlushLimit = scBatchBufferFlushLimit;
    return this;
  }

   /**
   * Max elements to flush in one shot from the internal buffer by the statecache thread. Allowed values are 1-10000. Field introduced in 18.2.5.
   * @return scBatchBufferFlushLimit
  **/
  @Schema(description = "Max elements to flush in one shot from the internal buffer by the statecache thread. Allowed values are 1-10000. Field introduced in 18.2.5.")
  public Integer getScBatchBufferFlushLimit() {
    return scBatchBufferFlushLimit;
  }

  public void setScBatchBufferFlushLimit(Integer scBatchBufferFlushLimit) {
    this.scBatchBufferFlushLimit = scBatchBufferFlushLimit;
  }

  public SeAgentStateCacheProperties scShardCleanupMaxTime(Integer scShardCleanupMaxTime) {
    this.scShardCleanupMaxTime = scShardCleanupMaxTime;
    return this;
  }

   /**
   * Max time to wait by the statecache thread before cleaning up connection to the controller shard. Allowed values are 1-1000000. Field introduced in 18.2.5.
   * @return scShardCleanupMaxTime
  **/
  @Schema(description = "Max time to wait by the statecache thread before cleaning up connection to the controller shard. Allowed values are 1-1000000. Field introduced in 18.2.5.")
  public Integer getScShardCleanupMaxTime() {
    return scShardCleanupMaxTime;
  }

  public void setScShardCleanupMaxTime(Integer scShardCleanupMaxTime) {
    this.scShardCleanupMaxTime = scShardCleanupMaxTime;
  }

  public SeAgentStateCacheProperties scStateRingBatchDequeueLimit(Integer scStateRingBatchDequeueLimit) {
    this.scStateRingBatchDequeueLimit = scStateRingBatchDequeueLimit;
    return this;
  }

   /**
   * Max elements to dequeue in one shot from the state_ring by the statecache thread. Allowed values are 1-10000. Field introduced in 18.2.5.
   * @return scStateRingBatchDequeueLimit
  **/
  @Schema(description = "Max elements to dequeue in one shot from the state_ring by the statecache thread. Allowed values are 1-10000. Field introduced in 18.2.5.")
  public Integer getScStateRingBatchDequeueLimit() {
    return scStateRingBatchDequeueLimit;
  }

  public void setScStateRingBatchDequeueLimit(Integer scStateRingBatchDequeueLimit) {
    this.scStateRingBatchDequeueLimit = scStateRingBatchDequeueLimit;
  }

  public SeAgentStateCacheProperties scStatesFlushInterval(Integer scStatesFlushInterval) {
    this.scStatesFlushInterval = scStatesFlushInterval;
    return this;
  }

   /**
   * Interval for update of operational states to controller. Allowed values are 1-10000. Field introduced in 18.2.5.
   * @return scStatesFlushInterval
  **/
  @Schema(description = "Interval for update of operational states to controller. Allowed values are 1-10000. Field introduced in 18.2.5.")
  public Integer getScStatesFlushInterval() {
    return scStatesFlushInterval;
  }

  public void setScStatesFlushInterval(Integer scStatesFlushInterval) {
    this.scStatesFlushInterval = scStatesFlushInterval;
  }

  public SeAgentStateCacheProperties scStreamCheckInterval(Integer scStreamCheckInterval) {
    this.scStreamCheckInterval = scStreamCheckInterval;
    return this;
  }

   /**
   * Interval for checking health of grpc streams to statecache_mgr. Allowed values are 1-90000. Field introduced in 18.2.5.
   * @return scStreamCheckInterval
  **/
  @Schema(description = "Interval for checking health of grpc streams to statecache_mgr. Allowed values are 1-90000. Field introduced in 18.2.5.")
  public Integer getScStreamCheckInterval() {
    return scStreamCheckInterval;
  }

  public void setScStreamCheckInterval(Integer scStreamCheckInterval) {
    this.scStreamCheckInterval = scStreamCheckInterval;
  }

  public SeAgentStateCacheProperties scThreadQBatchDequeueLimit(Integer scThreadQBatchDequeueLimit) {
    this.scThreadQBatchDequeueLimit = scThreadQBatchDequeueLimit;
    return this;
  }

   /**
   * Max elements to dequeue in one shot from the Q by the statecache thread. Allowed values are 1-10000. Field introduced in 18.2.5.
   * @return scThreadQBatchDequeueLimit
  **/
  @Schema(description = "Max elements to dequeue in one shot from the Q by the statecache thread. Allowed values are 1-10000. Field introduced in 18.2.5.")
  public Integer getScThreadQBatchDequeueLimit() {
    return scThreadQBatchDequeueLimit;
  }

  public void setScThreadQBatchDequeueLimit(Integer scThreadQBatchDequeueLimit) {
    this.scThreadQBatchDequeueLimit = scThreadQBatchDequeueLimit;
  }

  public SeAgentStateCacheProperties scThreadQMaxSize(Integer scThreadQMaxSize) {
    this.scThreadQMaxSize = scThreadQMaxSize;
    return this;
  }

   /**
   * Max elements in the Q between seagent main and the statecache thread. Allowed values are 1-10000. Field introduced in 18.2.5.
   * @return scThreadQMaxSize
  **/
  @Schema(description = "Max elements in the Q between seagent main and the statecache thread. Allowed values are 1-10000. Field introduced in 18.2.5.")
  public Integer getScThreadQMaxSize() {
    return scThreadQMaxSize;
  }

  public void setScThreadQMaxSize(Integer scThreadQMaxSize) {
    this.scThreadQMaxSize = scThreadQMaxSize;
  }

  public SeAgentStateCacheProperties scThreadSleepInterval(Integer scThreadSleepInterval) {
    this.scThreadSleepInterval = scThreadSleepInterval;
    return this;
  }

   /**
   * Interval for grpc thread to sleep between doing work. Allowed values are 1-10000. Field introduced in 18.2.5.
   * @return scThreadSleepInterval
  **/
  @Schema(description = "Interval for grpc thread to sleep between doing work. Allowed values are 1-10000. Field introduced in 18.2.5.")
  public Integer getScThreadSleepInterval() {
    return scThreadSleepInterval;
  }

  public void setScThreadSleepInterval(Integer scThreadSleepInterval) {
    this.scThreadSleepInterval = scThreadSleepInterval;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SeAgentStateCacheProperties seAgentStateCacheProperties = (SeAgentStateCacheProperties) o;
    return Objects.equals(this.scBatchBufferFlushLimit, seAgentStateCacheProperties.scBatchBufferFlushLimit) &&
        Objects.equals(this.scShardCleanupMaxTime, seAgentStateCacheProperties.scShardCleanupMaxTime) &&
        Objects.equals(this.scStateRingBatchDequeueLimit, seAgentStateCacheProperties.scStateRingBatchDequeueLimit) &&
        Objects.equals(this.scStatesFlushInterval, seAgentStateCacheProperties.scStatesFlushInterval) &&
        Objects.equals(this.scStreamCheckInterval, seAgentStateCacheProperties.scStreamCheckInterval) &&
        Objects.equals(this.scThreadQBatchDequeueLimit, seAgentStateCacheProperties.scThreadQBatchDequeueLimit) &&
        Objects.equals(this.scThreadQMaxSize, seAgentStateCacheProperties.scThreadQMaxSize) &&
        Objects.equals(this.scThreadSleepInterval, seAgentStateCacheProperties.scThreadSleepInterval);
  }

  @Override
  public int hashCode() {
    return Objects.hash(scBatchBufferFlushLimit, scShardCleanupMaxTime, scStateRingBatchDequeueLimit, scStatesFlushInterval, scStreamCheckInterval, scThreadQBatchDequeueLimit, scThreadQMaxSize, scThreadSleepInterval);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SeAgentStateCacheProperties {\n");
    
    sb.append("    scBatchBufferFlushLimit: ").append(toIndentedString(scBatchBufferFlushLimit)).append("\n");
    sb.append("    scShardCleanupMaxTime: ").append(toIndentedString(scShardCleanupMaxTime)).append("\n");
    sb.append("    scStateRingBatchDequeueLimit: ").append(toIndentedString(scStateRingBatchDequeueLimit)).append("\n");
    sb.append("    scStatesFlushInterval: ").append(toIndentedString(scStatesFlushInterval)).append("\n");
    sb.append("    scStreamCheckInterval: ").append(toIndentedString(scStreamCheckInterval)).append("\n");
    sb.append("    scThreadQBatchDequeueLimit: ").append(toIndentedString(scThreadQBatchDequeueLimit)).append("\n");
    sb.append("    scThreadQMaxSize: ").append(toIndentedString(scThreadQMaxSize)).append("\n");
    sb.append("    scThreadSleepInterval: ").append(toIndentedString(scThreadSleepInterval)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
