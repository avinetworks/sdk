/*
 * Avi avi_global_spec Object API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 20.1.1
 * Contact: support@avinetworks.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.vmware.avi.sdk.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.vmware.avi.sdk.model.CustomTag;
import com.vmware.avi.sdk.model.DosThresholdProfile;
import com.vmware.avi.sdk.model.IpAddr;
import com.vmware.avi.sdk.model.IpAddrPrefix;
import com.vmware.avi.sdk.model.IptableRuleSet;
import com.vmware.avi.sdk.model.MetricsRealTimeUpdate;
import com.vmware.avi.sdk.model.PortRange;
import com.vmware.avi.sdk.model.RateLimiterProperties;
import com.vmware.avi.sdk.model.VcenterClusters;
import com.vmware.avi.sdk.model.VcenterDatastore;
import com.vmware.avi.sdk.model.VcenterHosts;
import com.vmware.avi.sdk.model.VipAutoscaleGroup;
import com.vmware.avi.sdk.model.VssPlacement;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.List;
/**
 * ServiceEngineGroup
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-12T12:27:26.755+05:30[Asia/Kolkata]")
public class ServiceEngineGroup {
  @JsonProperty("_last_modified")
  private String _lastModified = null;

  @JsonProperty("accelerated_networking")
  private Boolean acceleratedNetworking = null;

  @JsonProperty("active_standby")
  private Boolean activeStandby = null;

  @JsonProperty("additional_config_memory")
  private Integer additionalConfigMemory = null;

  @JsonProperty("advertise_backend_networks")
  private Boolean advertiseBackendNetworks = null;

  @JsonProperty("aggressive_failure_detection")
  private Boolean aggressiveFailureDetection = null;

  @JsonProperty("algo")
  private String algo = "PLACEMENT_ALGO_PACKED";

  @JsonProperty("allow_burst")
  private Boolean allowBurst = null;

  @JsonProperty("app_cache_percent")
  private Integer appCachePercent = 10;

  @JsonProperty("app_cache_threshold")
  private Integer appCacheThreshold = 5;

  @JsonProperty("app_learning_memory_percent")
  private Integer appLearningMemoryPercent = null;

  @JsonProperty("archive_shm_limit")
  private Integer archiveShmLimit = 8;

  @JsonProperty("async_ssl")
  private Boolean asyncSsl = null;

  @JsonProperty("async_ssl_threads")
  private Integer asyncSslThreads = 1;

  @JsonProperty("auto_rebalance")
  private Boolean autoRebalance = null;

  @JsonProperty("auto_rebalance_capacity_per_se")
  private List<Integer> autoRebalanceCapacityPerSe = null;

  @JsonProperty("auto_rebalance_criteria")
  private List<String> autoRebalanceCriteria = null;

  @JsonProperty("auto_rebalance_interval")
  private Integer autoRebalanceInterval = 300;

  @JsonProperty("auto_redistribute_active_standby_load")
  private Boolean autoRedistributeActiveStandbyLoad = null;

  @JsonProperty("bgp_state_update_interval")
  private Integer bgpStateUpdateInterval = 60;

  @JsonProperty("buffer_se")
  private Integer bufferSe = 1;

  @JsonProperty("cloud_ref")
  private String cloudRef = null;

  @JsonProperty("config_debugs_on_all_cores")
  private Boolean configDebugsOnAllCores = null;

  @JsonProperty("connection_memory_percentage")
  private Integer connectionMemoryPercentage = 50;

  @JsonProperty("core_shm_app_cache")
  private Boolean coreShmAppCache = null;

  @JsonProperty("core_shm_app_learning")
  private Boolean coreShmAppLearning = null;

  @JsonProperty("cpu_reserve")
  private Boolean cpuReserve = null;

  @JsonProperty("cpu_socket_affinity")
  private Boolean cpuSocketAffinity = null;

  @JsonProperty("custom_securitygroups_data")
  private List<String> customSecuritygroupsData = null;

  @JsonProperty("custom_securitygroups_mgmt")
  private List<String> customSecuritygroupsMgmt = null;

  @JsonProperty("custom_tag")
  private List<CustomTag> customTag = null;

  @JsonProperty("data_network_id")
  private String dataNetworkId = null;

  @JsonProperty("datascript_timeout")
  private Long datascriptTimeout = 1000000l;

  @JsonProperty("dedicated_dispatcher_core")
  private Boolean dedicatedDispatcherCore = null;

  @JsonProperty("description")
  private String description = null;

  @JsonProperty("disable_avi_securitygroups")
  private Boolean disableAviSecuritygroups = null;

  @JsonProperty("disable_csum_offloads")
  private Boolean disableCsumOffloads = null;

  @JsonProperty("disable_gro")
  private Boolean disableGro = true;

  @JsonProperty("disable_se_memory_check")
  private Boolean disableSeMemoryCheck = null;

  @JsonProperty("disable_tso")
  private Boolean disableTso = null;

  @JsonProperty("disk_per_se")
  private Integer diskPerSe = 10;

  @JsonProperty("distribute_load_active_standby")
  private Boolean distributeLoadActiveStandby = null;

  @JsonProperty("distribute_queues")
  private Boolean distributeQueues = null;

  @JsonProperty("distribute_vnics")
  private Boolean distributeVnics = null;

  @JsonProperty("enable_gratarp_permanent")
  private Boolean enableGratarpPermanent = null;

  @JsonProperty("enable_hsm_priming")
  private Boolean enableHsmPriming = null;

  @JsonProperty("enable_multi_lb")
  private Boolean enableMultiLb = null;

  @JsonProperty("enable_pcap_tx_ring")
  private Boolean enablePcapTxRing = null;

  @JsonProperty("enable_routing")
  private Boolean enableRouting = null;

  @JsonProperty("enable_vip_on_all_interfaces")
  private Boolean enableVipOnAllInterfaces = null;

  @JsonProperty("enable_vmac")
  private Boolean enableVmac = null;

  @JsonProperty("ephemeral_portrange_end")
  private Integer ephemeralPortrangeEnd = null;

  @JsonProperty("ephemeral_portrange_start")
  private Integer ephemeralPortrangeStart = null;

  @JsonProperty("extra_config_multiplier")
  private Double extraConfigMultiplier = null;

  @JsonProperty("extra_shared_config_memory")
  private Integer extraSharedConfigMemory = null;

  @JsonProperty("floating_intf_ip")
  private List<IpAddr> floatingIntfIp = null;

  @JsonProperty("floating_intf_ip_se_2")
  private List<IpAddr> floatingIntfIpSe2 = null;

  @JsonProperty("flow_table_new_syn_max_entries")
  private Integer flowTableNewSynMaxEntries = null;

  @JsonProperty("free_list_size")
  private Integer freeListSize = 1024;

  @JsonProperty("gratarp_permanent_periodicity")
  private Integer gratarpPermanentPeriodicity = 10;

  @JsonProperty("ha_mode")
  private String haMode = "HA_MODE_SHARED";

  @JsonProperty("hardwaresecuritymodulegroup_ref")
  private String hardwaresecuritymodulegroupRef = null;

  @JsonProperty("heap_minimum_config_memory")
  private Integer heapMinimumConfigMemory = 8;

  @JsonProperty("hm_on_standby")
  private Boolean hmOnStandby = true;

  @JsonProperty("host_attribute_key")
  private String hostAttributeKey = null;

  @JsonProperty("host_attribute_value")
  private String hostAttributeValue = null;

  @JsonProperty("host_gateway_monitor")
  private Boolean hostGatewayMonitor = null;

  @JsonProperty("hypervisor")
  private String hypervisor = null;

  @JsonProperty("ignore_rtt_threshold")
  private Integer ignoreRttThreshold = 5000;

  @JsonProperty("ingress_access_data")
  private String ingressAccessData = "SG_INGRESS_ACCESS_ALL";

  @JsonProperty("ingress_access_mgmt")
  private String ingressAccessMgmt = "SG_INGRESS_ACCESS_ALL";

  @JsonProperty("instance_flavor")
  private String instanceFlavor = null;

  @JsonProperty("iptables")
  private List<IptableRuleSet> iptables = null;

  @JsonProperty("least_load_core_selection")
  private Boolean leastLoadCoreSelection = true;

  @JsonProperty("license_tier")
  private String licenseTier = null;

  @JsonProperty("license_type")
  private String licenseType = null;

  @JsonProperty("log_disksz")
  private Integer logDisksz = 10000;

  @JsonProperty("max_concurrent_external_hm")
  private Integer maxConcurrentExternalHm = null;

  @JsonProperty("max_cpu_usage")
  private Integer maxCpuUsage = 80;

  @JsonProperty("max_memory_per_mempool")
  private Integer maxMemoryPerMempool = 64;

  @JsonProperty("max_num_se_dps")
  private Integer maxNumSeDps = null;

  @JsonProperty("max_public_ips_per_lb")
  private Integer maxPublicIpsPerLb = 30;

  @JsonProperty("max_queues_per_vnic")
  private Integer maxQueuesPerVnic = 1;

  @JsonProperty("max_rules_per_lb")
  private Integer maxRulesPerLb = 150;

  @JsonProperty("max_scaleout_per_vs")
  private Integer maxScaleoutPerVs = 4;

  @JsonProperty("max_se")
  private Integer maxSe = 10;

  @JsonProperty("max_vs_per_se")
  private Integer maxVsPerSe = 10;

  @JsonProperty("mem_reserve")
  private Boolean memReserve = true;

  @JsonProperty("memory_for_config_update")
  private Integer memoryForConfigUpdate = 15;

  @JsonProperty("memory_per_se")
  private Integer memoryPerSe = 2048;

  @JsonProperty("mgmt_network_ref")
  private String mgmtNetworkRef = null;

  @JsonProperty("mgmt_subnet")
  private IpAddrPrefix mgmtSubnet = null;

  @JsonProperty("min_cpu_usage")
  private Integer minCpuUsage = 30;

  @JsonProperty("min_scaleout_per_vs")
  private Integer minScaleoutPerVs = 1;

  @JsonProperty("min_se")
  private Integer minSe = 1;

  @JsonProperty("minimum_connection_memory")
  private Integer minimumConnectionMemory = 20;

  @JsonProperty("minimum_required_config_memory")
  private Integer minimumRequiredConfigMemory = null;

  @JsonProperty("n_log_streaming_threads")
  private Integer nLogStreamingThreads = 1;

  @JsonProperty("name")
  private String name = null;

  @JsonProperty("nat_flow_tcp_closed_timeout")
  private Integer natFlowTcpClosedTimeout = null;

  @JsonProperty("nat_flow_tcp_established_timeout")
  private Integer natFlowTcpEstablishedTimeout = null;

  @JsonProperty("nat_flow_tcp_half_closed_timeout")
  private Integer natFlowTcpHalfClosedTimeout = null;

  @JsonProperty("nat_flow_tcp_handshake_timeout")
  private Integer natFlowTcpHandshakeTimeout = null;

  @JsonProperty("nat_flow_udp_noresponse_timeout")
  private Integer natFlowUdpNoresponseTimeout = null;

  @JsonProperty("nat_flow_udp_response_timeout")
  private Integer natFlowUdpResponseTimeout = null;

  @JsonProperty("non_significant_log_throttle")
  private Integer nonSignificantLogThrottle = 100;

  @JsonProperty("num_dispatcher_cores")
  private Integer numDispatcherCores = null;

  @JsonProperty("num_flow_cores_sum_changes_to_ignore")
  private Integer numFlowCoresSumChangesToIgnore = 8;

  @JsonProperty("openstack_availability_zone")
  private String openstackAvailabilityZone = null;

  @JsonProperty("openstack_availability_zones")
  private List<String> openstackAvailabilityZones = null;

  @JsonProperty("openstack_mgmt_network_name")
  private String openstackMgmtNetworkName = null;

  @JsonProperty("openstack_mgmt_network_uuid")
  private String openstackMgmtNetworkUuid = null;

  @JsonProperty("os_reserved_memory")
  private Integer osReservedMemory = null;

  @JsonProperty("pcap_tx_mode")
  private String pcapTxMode = "PCAP_TX_AUTO";

  @JsonProperty("per_app")
  private Boolean perApp = null;

  @JsonProperty("placement_mode")
  private String placementMode = "PLACEMENT_MODE_AUTO";

  @JsonProperty("realtime_se_metrics")
  private MetricsRealTimeUpdate realtimeSeMetrics = null;

  @JsonProperty("reboot_on_panic")
  private Boolean rebootOnPanic = true;

  @JsonProperty("reboot_on_stop")
  private Boolean rebootOnStop = null;

  @JsonProperty("se_bandwidth_type")
  private String seBandwidthType = null;

  @JsonProperty("se_deprovision_delay")
  private Integer seDeprovisionDelay = 120;

  @JsonProperty("se_dos_profile")
  private DosThresholdProfile seDosProfile = null;

  @JsonProperty("se_dp_max_hb_version")
  private Integer seDpMaxHbVersion = 2;

  @JsonProperty("se_dp_vnic_queue_stall_event_sleep")
  private Integer seDpVnicQueueStallEventSleep = null;

  @JsonProperty("se_dp_vnic_queue_stall_threshold")
  private Integer seDpVnicQueueStallThreshold = 2000;

  @JsonProperty("se_dp_vnic_queue_stall_timeout")
  private Integer seDpVnicQueueStallTimeout = 10000;

  @JsonProperty("se_dp_vnic_restart_on_queue_stall_count")
  private Integer seDpVnicRestartOnQueueStallCount = 3;

  @JsonProperty("se_dp_vnic_stall_se_restart_window")
  private Integer seDpVnicStallSeRestartWindow = 3600;

  @JsonProperty("se_dpdk_pmd")
  private Integer seDpdkPmd = null;

  @JsonProperty("se_flow_probe_retries")
  private Integer seFlowProbeRetries = 2;

  @JsonProperty("se_flow_probe_retry_timer")
  private Integer seFlowProbeRetryTimer = 40;

  @JsonProperty("se_flow_probe_timer")
  private Integer seFlowProbeTimer = null;

  @JsonProperty("se_ipc_udp_port")
  private Integer seIpcUdpPort = null;

  @JsonProperty("se_kni_burst_factor")
  private Integer seKniBurstFactor = null;

  @JsonProperty("se_lro")
  private Boolean seLro = true;

  @JsonProperty("se_mtu")
  private Integer seMtu = null;

  @JsonProperty("se_name_prefix")
  private String seNamePrefix = "Avi";

  @JsonProperty("se_pcap_lookahead")
  private Boolean sePcapLookahead = null;

  @JsonProperty("se_pcap_pkt_count")
  private Integer sePcapPktCount = null;

  @JsonProperty("se_pcap_pkt_sz")
  private Integer sePcapPktSz = 69632;

  @JsonProperty("se_pcap_qdisc_bypass")
  private Boolean sePcapQdiscBypass = true;

  @JsonProperty("se_pcap_reinit_frequency")
  private Integer sePcapReinitFrequency = null;

  @JsonProperty("se_pcap_reinit_threshold")
  private Integer sePcapReinitThreshold = null;

  @JsonProperty("se_probe_port")
  private Integer seProbePort = 7;

  @JsonProperty("se_remote_punt_udp_port")
  private Integer seRemotePuntUdpPort = null;

  @JsonProperty("se_rl_prop")
  private RateLimiterProperties seRlProp = null;

  @JsonProperty("se_routing")
  private Boolean seRouting = null;

  @JsonProperty("se_rum_sampling_nav_interval")
  private Integer seRumSamplingNavInterval = 1;

  @JsonProperty("se_rum_sampling_nav_percent")
  private Integer seRumSamplingNavPercent = 1;

  @JsonProperty("se_rum_sampling_res_interval")
  private Integer seRumSamplingResInterval = 2;

  @JsonProperty("se_rum_sampling_res_percent")
  private Integer seRumSamplingResPercent = 100;

  @JsonProperty("se_sb_dedicated_core")
  private Boolean seSbDedicatedCore = null;

  @JsonProperty("se_sb_threads")
  private Integer seSbThreads = 1;

  @JsonProperty("se_thread_multiplier")
  private Integer seThreadMultiplier = 1;

  @JsonProperty("se_tracert_port_range")
  private PortRange seTracertPortRange = null;

  @JsonProperty("se_tunnel_mode")
  private Integer seTunnelMode = null;

  @JsonProperty("se_tunnel_udp_port")
  private Integer seTunnelUdpPort = 1550;

  @JsonProperty("se_tx_batch_size")
  private Integer seTxBatchSize = 64;

  @JsonProperty("se_udp_encap_ipc")
  private Integer seUdpEncapIpc = null;

  @JsonProperty("se_use_dpdk")
  private Integer seUseDpdk = null;

  @JsonProperty("se_vs_hb_max_pkts_in_batch")
  private Integer seVsHbMaxPktsInBatch = 64;

  @JsonProperty("se_vs_hb_max_vs_in_pkt")
  private Integer seVsHbMaxVsInPkt = 256;

  @JsonProperty("self_se_election")
  private Boolean selfSeElection = null;

  @JsonProperty("service_ip6_subnets")
  private List<IpAddrPrefix> serviceIp6Subnets = null;

  @JsonProperty("service_ip_subnets")
  private List<IpAddrPrefix> serviceIpSubnets = null;

  @JsonProperty("shm_minimum_config_memory")
  private Integer shmMinimumConfigMemory = 4;

  @JsonProperty("significant_log_throttle")
  private Integer significantLogThrottle = 100;

  @JsonProperty("ssl_preprocess_sni_hostname")
  private Boolean sslPreprocessSniHostname = true;

  @JsonProperty("tenant_ref")
  private String tenantRef = null;

  @JsonProperty("udf_log_throttle")
  private Integer udfLogThrottle = 100;

  @JsonProperty("url")
  private String url = null;

  @JsonProperty("use_standard_alb")
  private Boolean useStandardAlb = null;

  @JsonProperty("uuid")
  private String uuid = null;

  @JsonProperty("vcenter_clusters")
  private VcenterClusters vcenterClusters = null;

  @JsonProperty("vcenter_datastore_mode")
  private String vcenterDatastoreMode = "VCENTER_DATASTORE_ANY";

  @JsonProperty("vcenter_datastores")
  private List<VcenterDatastore> vcenterDatastores = null;

  @JsonProperty("vcenter_datastores_include")
  private Boolean vcenterDatastoresInclude = null;

  @JsonProperty("vcenter_folder")
  private String vcenterFolder = "AviSeFolder";

  @JsonProperty("vcenter_hosts")
  private VcenterHosts vcenterHosts = null;

  @JsonProperty("vcpus_per_se")
  private Integer vcpusPerSe = 1;

  @JsonProperty("vip_asg")
  private VipAutoscaleGroup vipAsg = null;

  @JsonProperty("vs_host_redundancy")
  private Boolean vsHostRedundancy = true;

  @JsonProperty("vs_scalein_timeout")
  private Integer vsScaleinTimeout = 30;

  @JsonProperty("vs_scalein_timeout_for_upgrade")
  private Integer vsScaleinTimeoutForUpgrade = 30;

  @JsonProperty("vs_scaleout_timeout")
  private Integer vsScaleoutTimeout = 600;

  @JsonProperty("vs_se_scaleout_additional_wait_time")
  private Integer vsSeScaleoutAdditionalWaitTime = null;

  @JsonProperty("vs_se_scaleout_ready_timeout")
  private Integer vsSeScaleoutReadyTimeout = 60;

  @JsonProperty("vs_switchover_timeout")
  private Integer vsSwitchoverTimeout = 300;

  @JsonProperty("vss_placement")
  private VssPlacement vssPlacement = null;

  @JsonProperty("vss_placement_enabled")
  private Boolean vssPlacementEnabled = null;

  @JsonProperty("waf_learning_interval")
  private Integer wafLearningInterval = null;

  @JsonProperty("waf_learning_memory")
  private Integer wafLearningMemory = null;

  @JsonProperty("waf_mempool")
  private Boolean wafMempool = true;

  @JsonProperty("waf_mempool_size")
  private Integer wafMempoolSize = 64;

   /**
   * UNIX time since epoch in microseconds. Units(MICROSECONDS).
   * @return _lastModified
  **/
  @Schema(description = "UNIX time since epoch in microseconds. Units(MICROSECONDS).")
  public String getLastModified() {
    return _lastModified;
  }

  public ServiceEngineGroup acceleratedNetworking(Boolean acceleratedNetworking) {
    this.acceleratedNetworking = acceleratedNetworking;
    return this;
  }

   /**
   * Enable accelerated networking option for Azure SE. Accelerated networking enables single root I/O virtualization (SR-IOV) to a SE VM. This improves networking performance. Field introduced in 17.2.14,18.1.5,18.2.1.
   * @return acceleratedNetworking
  **/
  @Schema(description = "Enable accelerated networking option for Azure SE. Accelerated networking enables single root I/O virtualization (SR-IOV) to a SE VM. This improves networking performance. Field introduced in 17.2.14,18.1.5,18.2.1.")
  public Boolean isAcceleratedNetworking() {
    return acceleratedNetworking;
  }

  public void setAcceleratedNetworking(Boolean acceleratedNetworking) {
    this.acceleratedNetworking = acceleratedNetworking;
  }

  public ServiceEngineGroup activeStandby(Boolean activeStandby) {
    this.activeStandby = activeStandby;
    return this;
  }

   /**
   * Service Engines in active/standby mode for HA failover.
   * @return activeStandby
  **/
  @Schema(description = "Service Engines in active/standby mode for HA failover.")
  public Boolean isActiveStandby() {
    return activeStandby;
  }

  public void setActiveStandby(Boolean activeStandby) {
    this.activeStandby = activeStandby;
  }

  public ServiceEngineGroup additionalConfigMemory(Integer additionalConfigMemory) {
    this.additionalConfigMemory = additionalConfigMemory;
    return this;
  }

   /**
   * Indicates the percent of config memory used for config updates. Allowed values are 0-90. Field deprecated in 18.1.2. Field introduced in 18.1.1.
   * @return additionalConfigMemory
  **/
  @Schema(description = "Indicates the percent of config memory used for config updates. Allowed values are 0-90. Field deprecated in 18.1.2. Field introduced in 18.1.1.")
  public Integer getAdditionalConfigMemory() {
    return additionalConfigMemory;
  }

  public void setAdditionalConfigMemory(Integer additionalConfigMemory) {
    this.additionalConfigMemory = additionalConfigMemory;
  }

  public ServiceEngineGroup advertiseBackendNetworks(Boolean advertiseBackendNetworks) {
    this.advertiseBackendNetworks = advertiseBackendNetworks;
    return this;
  }

   /**
   * Advertise reach-ability of backend server networks via ADC through BGP for default gateway feature. Field deprecated in 18.2.5.
   * @return advertiseBackendNetworks
  **/
  @Schema(description = "Advertise reach-ability of backend server networks via ADC through BGP for default gateway feature. Field deprecated in 18.2.5.")
  public Boolean isAdvertiseBackendNetworks() {
    return advertiseBackendNetworks;
  }

  public void setAdvertiseBackendNetworks(Boolean advertiseBackendNetworks) {
    this.advertiseBackendNetworks = advertiseBackendNetworks;
  }

  public ServiceEngineGroup aggressiveFailureDetection(Boolean aggressiveFailureDetection) {
    this.aggressiveFailureDetection = aggressiveFailureDetection;
    return this;
  }

   /**
   * Enable aggressive failover configuration for ha.
   * @return aggressiveFailureDetection
  **/
  @Schema(description = "Enable aggressive failover configuration for ha.")
  public Boolean isAggressiveFailureDetection() {
    return aggressiveFailureDetection;
  }

  public void setAggressiveFailureDetection(Boolean aggressiveFailureDetection) {
    this.aggressiveFailureDetection = aggressiveFailureDetection;
  }

  public ServiceEngineGroup algo(String algo) {
    this.algo = algo;
    return this;
  }

   /**
   * In compact placement, Virtual Services are placed on existing SEs until max_vs_per_se limit is reached. Enum options - PLACEMENT_ALGO_PACKED, PLACEMENT_ALGO_DISTRIBUTED.
   * @return algo
  **/
  @Schema(description = "In compact placement, Virtual Services are placed on existing SEs until max_vs_per_se limit is reached. Enum options - PLACEMENT_ALGO_PACKED, PLACEMENT_ALGO_DISTRIBUTED.")
  public String getAlgo() {
    return algo;
  }

  public void setAlgo(String algo) {
    this.algo = algo;
  }

  public ServiceEngineGroup allowBurst(Boolean allowBurst) {
    this.allowBurst = allowBurst;
    return this;
  }

   /**
   * Allow SEs to be created using burst license. Field introduced in 17.2.5.
   * @return allowBurst
  **/
  @Schema(description = "Allow SEs to be created using burst license. Field introduced in 17.2.5.")
  public Boolean isAllowBurst() {
    return allowBurst;
  }

  public void setAllowBurst(Boolean allowBurst) {
    this.allowBurst = allowBurst;
  }

  public ServiceEngineGroup appCachePercent(Integer appCachePercent) {
    this.appCachePercent = appCachePercent;
    return this;
  }

   /**
   * A percent value of total SE memory reserved for applicationcaching. This is an SE bootup property and requires SE restart.Requires SE Reboot. Allowed values are 0 - 100. Special values are 0- &#x27;disable&#x27;. Field introduced in 18.2.3.
   * @return appCachePercent
  **/
  @Schema(description = "A percent value of total SE memory reserved for applicationcaching. This is an SE bootup property and requires SE restart.Requires SE Reboot. Allowed values are 0 - 100. Special values are 0- 'disable'. Field introduced in 18.2.3.")
  public Integer getAppCachePercent() {
    return appCachePercent;
  }

  public void setAppCachePercent(Integer appCachePercent) {
    this.appCachePercent = appCachePercent;
  }

  public ServiceEngineGroup appCacheThreshold(Integer appCacheThreshold) {
    this.appCacheThreshold = appCacheThreshold;
    return this;
  }

   /**
   * The max memory that can be allocated for the app cache. This value will act as an upper bound on the cache size specified in app_cache_percent. Special values are 0- &#x27;disable&#x27;. Field introduced in 20.1.1.
   * @return appCacheThreshold
  **/
  @Schema(description = "The max memory that can be allocated for the app cache. This value will act as an upper bound on the cache size specified in app_cache_percent. Special values are 0- 'disable'. Field introduced in 20.1.1.")
  public Integer getAppCacheThreshold() {
    return appCacheThreshold;
  }

  public void setAppCacheThreshold(Integer appCacheThreshold) {
    this.appCacheThreshold = appCacheThreshold;
  }

  public ServiceEngineGroup appLearningMemoryPercent(Integer appLearningMemoryPercent) {
    this.appLearningMemoryPercent = appLearningMemoryPercent;
    return this;
  }

   /**
   * A percent value of total SE memory reserved for Application learning. This is an SE bootup property and requires SE restart. Allowed values are 0 - 10. Field introduced in 18.2.3.
   * @return appLearningMemoryPercent
  **/
  @Schema(description = "A percent value of total SE memory reserved for Application learning. This is an SE bootup property and requires SE restart. Allowed values are 0 - 10. Field introduced in 18.2.3.")
  public Integer getAppLearningMemoryPercent() {
    return appLearningMemoryPercent;
  }

  public void setAppLearningMemoryPercent(Integer appLearningMemoryPercent) {
    this.appLearningMemoryPercent = appLearningMemoryPercent;
  }

  public ServiceEngineGroup archiveShmLimit(Integer archiveShmLimit) {
    this.archiveShmLimit = archiveShmLimit;
    return this;
  }

   /**
   * Amount of SE memory in GB until which shared memory is collected in core archive. Field introduced in 17.1.3.
   * @return archiveShmLimit
  **/
  @Schema(description = "Amount of SE memory in GB until which shared memory is collected in core archive. Field introduced in 17.1.3.")
  public Integer getArchiveShmLimit() {
    return archiveShmLimit;
  }

  public void setArchiveShmLimit(Integer archiveShmLimit) {
    this.archiveShmLimit = archiveShmLimit;
  }

  public ServiceEngineGroup asyncSsl(Boolean asyncSsl) {
    this.asyncSsl = asyncSsl;
    return this;
  }

   /**
   * SSL handshakes will be handled by dedicated SSL Threads.Requires SE Reboot.
   * @return asyncSsl
  **/
  @Schema(description = "SSL handshakes will be handled by dedicated SSL Threads.Requires SE Reboot.")
  public Boolean isAsyncSsl() {
    return asyncSsl;
  }

  public void setAsyncSsl(Boolean asyncSsl) {
    this.asyncSsl = asyncSsl;
  }

  public ServiceEngineGroup asyncSslThreads(Integer asyncSslThreads) {
    this.asyncSslThreads = asyncSslThreads;
    return this;
  }

   /**
   * Number of Async SSL threads per se_dp.Requires SE Reboot. Allowed values are 1-16.
   * @return asyncSslThreads
  **/
  @Schema(description = "Number of Async SSL threads per se_dp.Requires SE Reboot. Allowed values are 1-16.")
  public Integer getAsyncSslThreads() {
    return asyncSslThreads;
  }

  public void setAsyncSslThreads(Integer asyncSslThreads) {
    this.asyncSslThreads = asyncSslThreads;
  }

  public ServiceEngineGroup autoRebalance(Boolean autoRebalance) {
    this.autoRebalance = autoRebalance;
    return this;
  }

   /**
   * If set, Virtual Services will be automatically migrated when load on an SE is less than minimum or more than maximum thresholds. Only Alerts are generated when the auto_rebalance is not set.
   * @return autoRebalance
  **/
  @Schema(description = "If set, Virtual Services will be automatically migrated when load on an SE is less than minimum or more than maximum thresholds. Only Alerts are generated when the auto_rebalance is not set.")
  public Boolean isAutoRebalance() {
    return autoRebalance;
  }

  public void setAutoRebalance(Boolean autoRebalance) {
    this.autoRebalance = autoRebalance;
  }

  public ServiceEngineGroup autoRebalanceCapacityPerSe(List<Integer> autoRebalanceCapacityPerSe) {
    this.autoRebalanceCapacityPerSe = autoRebalanceCapacityPerSe;
    return this;
  }

  public ServiceEngineGroup addAutoRebalanceCapacityPerSeItem(Integer autoRebalanceCapacityPerSeItem) {
    if (this.autoRebalanceCapacityPerSe == null) {
      this.autoRebalanceCapacityPerSe = new ArrayList<Integer>();
    }
    this.autoRebalanceCapacityPerSe.add(autoRebalanceCapacityPerSeItem);
    return this;
  }

   /**
   * Capacities of SE for auto rebalance for each criteria. Field introduced in 17.2.4.
   * @return autoRebalanceCapacityPerSe
  **/
  @Schema(description = "Capacities of SE for auto rebalance for each criteria. Field introduced in 17.2.4.")
  public List<Integer> getAutoRebalanceCapacityPerSe() {
    return autoRebalanceCapacityPerSe;
  }

  public void setAutoRebalanceCapacityPerSe(List<Integer> autoRebalanceCapacityPerSe) {
    this.autoRebalanceCapacityPerSe = autoRebalanceCapacityPerSe;
  }

  public ServiceEngineGroup autoRebalanceCriteria(List<String> autoRebalanceCriteria) {
    this.autoRebalanceCriteria = autoRebalanceCriteria;
    return this;
  }

  public ServiceEngineGroup addAutoRebalanceCriteriaItem(String autoRebalanceCriteriaItem) {
    if (this.autoRebalanceCriteria == null) {
      this.autoRebalanceCriteria = new ArrayList<String>();
    }
    this.autoRebalanceCriteria.add(autoRebalanceCriteriaItem);
    return this;
  }

   /**
   * Set of criteria for SE Auto Rebalance. Enum options - SE_AUTO_REBALANCE_CPU, SE_AUTO_REBALANCE_PPS, SE_AUTO_REBALANCE_MBPS, SE_AUTO_REBALANCE_OPEN_CONNS, SE_AUTO_REBALANCE_CPS. Field introduced in 17.2.3.
   * @return autoRebalanceCriteria
  **/
  @Schema(description = "Set of criteria for SE Auto Rebalance. Enum options - SE_AUTO_REBALANCE_CPU, SE_AUTO_REBALANCE_PPS, SE_AUTO_REBALANCE_MBPS, SE_AUTO_REBALANCE_OPEN_CONNS, SE_AUTO_REBALANCE_CPS. Field introduced in 17.2.3.")
  public List<String> getAutoRebalanceCriteria() {
    return autoRebalanceCriteria;
  }

  public void setAutoRebalanceCriteria(List<String> autoRebalanceCriteria) {
    this.autoRebalanceCriteria = autoRebalanceCriteria;
  }

  public ServiceEngineGroup autoRebalanceInterval(Integer autoRebalanceInterval) {
    this.autoRebalanceInterval = autoRebalanceInterval;
    return this;
  }

   /**
   * Frequency of rebalance, if &#x27;Auto rebalance&#x27; is enabled.
   * @return autoRebalanceInterval
  **/
  @Schema(description = "Frequency of rebalance, if 'Auto rebalance' is enabled.")
  public Integer getAutoRebalanceInterval() {
    return autoRebalanceInterval;
  }

  public void setAutoRebalanceInterval(Integer autoRebalanceInterval) {
    this.autoRebalanceInterval = autoRebalanceInterval;
  }

  public ServiceEngineGroup autoRedistributeActiveStandbyLoad(Boolean autoRedistributeActiveStandbyLoad) {
    this.autoRedistributeActiveStandbyLoad = autoRedistributeActiveStandbyLoad;
    return this;
  }

   /**
   * Redistribution of virtual services from the takeover SE to the replacement SE can cause momentary traffic loss. If the auto-redistribute load option is left in its default off state, any desired rebalancing requires calls to REST API.
   * @return autoRedistributeActiveStandbyLoad
  **/
  @Schema(description = "Redistribution of virtual services from the takeover SE to the replacement SE can cause momentary traffic loss. If the auto-redistribute load option is left in its default off state, any desired rebalancing requires calls to REST API.")
  public Boolean isAutoRedistributeActiveStandbyLoad() {
    return autoRedistributeActiveStandbyLoad;
  }

  public void setAutoRedistributeActiveStandbyLoad(Boolean autoRedistributeActiveStandbyLoad) {
    this.autoRedistributeActiveStandbyLoad = autoRedistributeActiveStandbyLoad;
  }

  public ServiceEngineGroup bgpStateUpdateInterval(Integer bgpStateUpdateInterval) {
    this.bgpStateUpdateInterval = bgpStateUpdateInterval;
    return this;
  }

   /**
   * BGP peer state update interval. Allowed values are 5-100. Field introduced in 17.2.14,18.1.5,18.2.1.
   * @return bgpStateUpdateInterval
  **/
  @Schema(description = "BGP peer state update interval. Allowed values are 5-100. Field introduced in 17.2.14,18.1.5,18.2.1.")
  public Integer getBgpStateUpdateInterval() {
    return bgpStateUpdateInterval;
  }

  public void setBgpStateUpdateInterval(Integer bgpStateUpdateInterval) {
    this.bgpStateUpdateInterval = bgpStateUpdateInterval;
  }

  public ServiceEngineGroup bufferSe(Integer bufferSe) {
    this.bufferSe = bufferSe;
    return this;
  }

   /**
   * Excess Service Engine capacity provisioned for HA failover.
   * @return bufferSe
  **/
  @Schema(description = "Excess Service Engine capacity provisioned for HA failover.")
  public Integer getBufferSe() {
    return bufferSe;
  }

  public void setBufferSe(Integer bufferSe) {
    this.bufferSe = bufferSe;
  }

  public ServiceEngineGroup cloudRef(String cloudRef) {
    this.cloudRef = cloudRef;
    return this;
  }

   /**
   *  It is a reference to an object of type Cloud.
   * @return cloudRef
  **/
  @Schema(description = " It is a reference to an object of type Cloud.")
  public String getCloudRef() {
    return cloudRef;
  }

  public void setCloudRef(String cloudRef) {
    this.cloudRef = cloudRef;
  }

  public ServiceEngineGroup configDebugsOnAllCores(Boolean configDebugsOnAllCores) {
    this.configDebugsOnAllCores = configDebugsOnAllCores;
    return this;
  }

   /**
   * Enable config debugs on all cores of SE. Field introduced in 17.2.13,18.1.5,18.2.1.
   * @return configDebugsOnAllCores
  **/
  @Schema(description = "Enable config debugs on all cores of SE. Field introduced in 17.2.13,18.1.5,18.2.1.")
  public Boolean isConfigDebugsOnAllCores() {
    return configDebugsOnAllCores;
  }

  public void setConfigDebugsOnAllCores(Boolean configDebugsOnAllCores) {
    this.configDebugsOnAllCores = configDebugsOnAllCores;
  }

  public ServiceEngineGroup connectionMemoryPercentage(Integer connectionMemoryPercentage) {
    this.connectionMemoryPercentage = connectionMemoryPercentage;
    return this;
  }

   /**
   * Percentage of memory for connection state. This will come at the expense of memory used for HTTP in-memory cache. Allowed values are 10-90.
   * @return connectionMemoryPercentage
  **/
  @Schema(description = "Percentage of memory for connection state. This will come at the expense of memory used for HTTP in-memory cache. Allowed values are 10-90.")
  public Integer getConnectionMemoryPercentage() {
    return connectionMemoryPercentage;
  }

  public void setConnectionMemoryPercentage(Integer connectionMemoryPercentage) {
    this.connectionMemoryPercentage = connectionMemoryPercentage;
  }

  public ServiceEngineGroup coreShmAppCache(Boolean coreShmAppCache) {
    this.coreShmAppCache = coreShmAppCache;
    return this;
  }

   /**
   * Include shared memory for app cache in core file.Requires SE Reboot. Field introduced in 18.2.8, 20.1.1.
   * @return coreShmAppCache
  **/
  @Schema(description = "Include shared memory for app cache in core file.Requires SE Reboot. Field introduced in 18.2.8, 20.1.1.")
  public Boolean isCoreShmAppCache() {
    return coreShmAppCache;
  }

  public void setCoreShmAppCache(Boolean coreShmAppCache) {
    this.coreShmAppCache = coreShmAppCache;
  }

  public ServiceEngineGroup coreShmAppLearning(Boolean coreShmAppLearning) {
    this.coreShmAppLearning = coreShmAppLearning;
    return this;
  }

   /**
   * Include shared memory for app learning in core file.Requires SE Reboot. Field introduced in 18.2.8, 20.1.1.
   * @return coreShmAppLearning
  **/
  @Schema(description = "Include shared memory for app learning in core file.Requires SE Reboot. Field introduced in 18.2.8, 20.1.1.")
  public Boolean isCoreShmAppLearning() {
    return coreShmAppLearning;
  }

  public void setCoreShmAppLearning(Boolean coreShmAppLearning) {
    this.coreShmAppLearning = coreShmAppLearning;
  }

  public ServiceEngineGroup cpuReserve(Boolean cpuReserve) {
    this.cpuReserve = cpuReserve;
    return this;
  }

   /**
   * Placeholder for description of property cpu_reserve of obj type ServiceEngineGroup field type str  type boolean
   * @return cpuReserve
  **/
  @Schema(description = "Placeholder for description of property cpu_reserve of obj type ServiceEngineGroup field type str  type boolean")
  public Boolean isCpuReserve() {
    return cpuReserve;
  }

  public void setCpuReserve(Boolean cpuReserve) {
    this.cpuReserve = cpuReserve;
  }

  public ServiceEngineGroup cpuSocketAffinity(Boolean cpuSocketAffinity) {
    this.cpuSocketAffinity = cpuSocketAffinity;
    return this;
  }

   /**
   * Allocate all the CPU cores for the Service Engine Virtual Machines  on the same CPU socket. Applicable only for vCenter Cloud.
   * @return cpuSocketAffinity
  **/
  @Schema(description = "Allocate all the CPU cores for the Service Engine Virtual Machines  on the same CPU socket. Applicable only for vCenter Cloud.")
  public Boolean isCpuSocketAffinity() {
    return cpuSocketAffinity;
  }

  public void setCpuSocketAffinity(Boolean cpuSocketAffinity) {
    this.cpuSocketAffinity = cpuSocketAffinity;
  }

  public ServiceEngineGroup customSecuritygroupsData(List<String> customSecuritygroupsData) {
    this.customSecuritygroupsData = customSecuritygroupsData;
    return this;
  }

  public ServiceEngineGroup addCustomSecuritygroupsDataItem(String customSecuritygroupsDataItem) {
    if (this.customSecuritygroupsData == null) {
      this.customSecuritygroupsData = new ArrayList<String>();
    }
    this.customSecuritygroupsData.add(customSecuritygroupsDataItem);
    return this;
  }

   /**
   * Custom Security Groups to be associated with data vNics for SE instances in OpenStack and AWS Clouds. Field introduced in 17.1.3.
   * @return customSecuritygroupsData
  **/
  @Schema(description = "Custom Security Groups to be associated with data vNics for SE instances in OpenStack and AWS Clouds. Field introduced in 17.1.3.")
  public List<String> getCustomSecuritygroupsData() {
    return customSecuritygroupsData;
  }

  public void setCustomSecuritygroupsData(List<String> customSecuritygroupsData) {
    this.customSecuritygroupsData = customSecuritygroupsData;
  }

  public ServiceEngineGroup customSecuritygroupsMgmt(List<String> customSecuritygroupsMgmt) {
    this.customSecuritygroupsMgmt = customSecuritygroupsMgmt;
    return this;
  }

  public ServiceEngineGroup addCustomSecuritygroupsMgmtItem(String customSecuritygroupsMgmtItem) {
    if (this.customSecuritygroupsMgmt == null) {
      this.customSecuritygroupsMgmt = new ArrayList<String>();
    }
    this.customSecuritygroupsMgmt.add(customSecuritygroupsMgmtItem);
    return this;
  }

   /**
   * Custom Security Groups to be associated with management vNic for SE instances in OpenStack and AWS Clouds. Field introduced in 17.1.3.
   * @return customSecuritygroupsMgmt
  **/
  @Schema(description = "Custom Security Groups to be associated with management vNic for SE instances in OpenStack and AWS Clouds. Field introduced in 17.1.3.")
  public List<String> getCustomSecuritygroupsMgmt() {
    return customSecuritygroupsMgmt;
  }

  public void setCustomSecuritygroupsMgmt(List<String> customSecuritygroupsMgmt) {
    this.customSecuritygroupsMgmt = customSecuritygroupsMgmt;
  }

  public ServiceEngineGroup customTag(List<CustomTag> customTag) {
    this.customTag = customTag;
    return this;
  }

  public ServiceEngineGroup addCustomTagItem(CustomTag customTagItem) {
    if (this.customTag == null) {
      this.customTag = new ArrayList<CustomTag>();
    }
    this.customTag.add(customTagItem);
    return this;
  }

   /**
   * Custom tag will be used to create the tags for SE instance in AWS. Note this is not the same as the prefix for SE name.
   * @return customTag
  **/
  @Schema(description = "Custom tag will be used to create the tags for SE instance in AWS. Note this is not the same as the prefix for SE name.")
  public List<CustomTag> getCustomTag() {
    return customTag;
  }

  public void setCustomTag(List<CustomTag> customTag) {
    this.customTag = customTag;
  }

  public ServiceEngineGroup dataNetworkId(String dataNetworkId) {
    this.dataNetworkId = dataNetworkId;
    return this;
  }

   /**
   * Subnet used to spin up the data nic for Service Engines, used only for Azure cloud. Overrides the cloud level setting for Service Engine subnet. Field introduced in 18.2.3.
   * @return dataNetworkId
  **/
  @Schema(description = "Subnet used to spin up the data nic for Service Engines, used only for Azure cloud. Overrides the cloud level setting for Service Engine subnet. Field introduced in 18.2.3.")
  public String getDataNetworkId() {
    return dataNetworkId;
  }

  public void setDataNetworkId(String dataNetworkId) {
    this.dataNetworkId = dataNetworkId;
  }

  public ServiceEngineGroup datascriptTimeout(Long datascriptTimeout) {
    this.datascriptTimeout = datascriptTimeout;
    return this;
  }

   /**
   * Number of instructions before datascript times out. Allowed values are 0-100000000. Field introduced in 18.2.3.
   * @return datascriptTimeout
  **/
  @Schema(description = "Number of instructions before datascript times out. Allowed values are 0-100000000. Field introduced in 18.2.3.")
  public Long getDatascriptTimeout() {
    return datascriptTimeout;
  }

  public void setDatascriptTimeout(Long datascriptTimeout) {
    this.datascriptTimeout = datascriptTimeout;
  }

  public ServiceEngineGroup dedicatedDispatcherCore(Boolean dedicatedDispatcherCore) {
    this.dedicatedDispatcherCore = dedicatedDispatcherCore;
    return this;
  }

   /**
   * Dedicate the core that handles packet receive/transmit from the network to just the dispatching function. Don&#x27;t use it for TCP/IP and SSL functions.
   * @return dedicatedDispatcherCore
  **/
  @Schema(description = "Dedicate the core that handles packet receive/transmit from the network to just the dispatching function. Don't use it for TCP/IP and SSL functions.")
  public Boolean isDedicatedDispatcherCore() {
    return dedicatedDispatcherCore;
  }

  public void setDedicatedDispatcherCore(Boolean dedicatedDispatcherCore) {
    this.dedicatedDispatcherCore = dedicatedDispatcherCore;
  }

  public ServiceEngineGroup description(String description) {
    this.description = description;
    return this;
  }

   /**
   * User defined description for the object.
   * @return description
  **/
  @Schema(description = "User defined description for the object.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public ServiceEngineGroup disableAviSecuritygroups(Boolean disableAviSecuritygroups) {
    this.disableAviSecuritygroups = disableAviSecuritygroups;
    return this;
  }

   /**
   * By default, Avi creates and manages security groups along with custom sg provided by user. Set this to True to disallow Avi to create and manage new security groups. Avi will only make use of custom security groups provided by user. This option is supported for AWS and OpenStack cloud types. Field introduced in 17.2.13,18.1.4,18.2.1.
   * @return disableAviSecuritygroups
  **/
  @Schema(description = "By default, Avi creates and manages security groups along with custom sg provided by user. Set this to True to disallow Avi to create and manage new security groups. Avi will only make use of custom security groups provided by user. This option is supported for AWS and OpenStack cloud types. Field introduced in 17.2.13,18.1.4,18.2.1.")
  public Boolean isDisableAviSecuritygroups() {
    return disableAviSecuritygroups;
  }

  public void setDisableAviSecuritygroups(Boolean disableAviSecuritygroups) {
    this.disableAviSecuritygroups = disableAviSecuritygroups;
  }

  public ServiceEngineGroup disableCsumOffloads(Boolean disableCsumOffloads) {
    this.disableCsumOffloads = disableCsumOffloads;
    return this;
  }

   /**
   * Stop using TCP/UDP and IP checksum offload features of NICs. Field introduced in 17.1.14, 17.2.5, 18.1.1.
   * @return disableCsumOffloads
  **/
  @Schema(description = "Stop using TCP/UDP and IP checksum offload features of NICs. Field introduced in 17.1.14, 17.2.5, 18.1.1.")
  public Boolean isDisableCsumOffloads() {
    return disableCsumOffloads;
  }

  public void setDisableCsumOffloads(Boolean disableCsumOffloads) {
    this.disableCsumOffloads = disableCsumOffloads;
  }

  public ServiceEngineGroup disableGro(Boolean disableGro) {
    this.disableGro = disableGro;
    return this;
  }

   /**
   * Disable Generic Receive Offload (GRO) in DPDK poll-mode driver packet receive path.  GRO is on by default on NICs that do not support LRO (Large Receive Offload) or do not gain performance boost from LRO. Field introduced in 17.2.5, 18.1.1.
   * @return disableGro
  **/
  @Schema(description = "Disable Generic Receive Offload (GRO) in DPDK poll-mode driver packet receive path.  GRO is on by default on NICs that do not support LRO (Large Receive Offload) or do not gain performance boost from LRO. Field introduced in 17.2.5, 18.1.1.")
  public Boolean isDisableGro() {
    return disableGro;
  }

  public void setDisableGro(Boolean disableGro) {
    this.disableGro = disableGro;
  }

  public ServiceEngineGroup disableSeMemoryCheck(Boolean disableSeMemoryCheck) {
    this.disableSeMemoryCheck = disableSeMemoryCheck;
    return this;
  }

   /**
   * If set, disable the config memory check done in service engine. Field introduced in 18.1.2.
   * @return disableSeMemoryCheck
  **/
  @Schema(description = "If set, disable the config memory check done in service engine. Field introduced in 18.1.2.")
  public Boolean isDisableSeMemoryCheck() {
    return disableSeMemoryCheck;
  }

  public void setDisableSeMemoryCheck(Boolean disableSeMemoryCheck) {
    this.disableSeMemoryCheck = disableSeMemoryCheck;
  }

  public ServiceEngineGroup disableTso(Boolean disableTso) {
    this.disableTso = disableTso;
    return this;
  }

   /**
   * Disable TCP Segmentation Offload (TSO) in DPDK poll-mode driver packet transmit path. TSO is on by default on NICs that support it. Field introduced in 17.2.5, 18.1.1.
   * @return disableTso
  **/
  @Schema(description = "Disable TCP Segmentation Offload (TSO) in DPDK poll-mode driver packet transmit path. TSO is on by default on NICs that support it. Field introduced in 17.2.5, 18.1.1.")
  public Boolean isDisableTso() {
    return disableTso;
  }

  public void setDisableTso(Boolean disableTso) {
    this.disableTso = disableTso;
  }

  public ServiceEngineGroup diskPerSe(Integer diskPerSe) {
    this.diskPerSe = diskPerSe;
    return this;
  }

   /**
   * Amount of disk space for each of the Service Engine virtual machines.
   * @return diskPerSe
  **/
  @Schema(description = "Amount of disk space for each of the Service Engine virtual machines.")
  public Integer getDiskPerSe() {
    return diskPerSe;
  }

  public void setDiskPerSe(Integer diskPerSe) {
    this.diskPerSe = diskPerSe;
  }

  public ServiceEngineGroup distributeLoadActiveStandby(Boolean distributeLoadActiveStandby) {
    this.distributeLoadActiveStandby = distributeLoadActiveStandby;
    return this;
  }

   /**
   * Use both the active and standby Service Engines for Virtual Service placement in the legacy active standby HA mode.
   * @return distributeLoadActiveStandby
  **/
  @Schema(description = "Use both the active and standby Service Engines for Virtual Service placement in the legacy active standby HA mode.")
  public Boolean isDistributeLoadActiveStandby() {
    return distributeLoadActiveStandby;
  }

  public void setDistributeLoadActiveStandby(Boolean distributeLoadActiveStandby) {
    this.distributeLoadActiveStandby = distributeLoadActiveStandby;
  }

  public ServiceEngineGroup distributeQueues(Boolean distributeQueues) {
    this.distributeQueues = distributeQueues;
    return this;
  }

   /**
   * Distributes queue ownership among cores so multiple cores handle dispatcher duties.Requires SE Reboot. Field introduced in 17.2.8.
   * @return distributeQueues
  **/
  @Schema(description = "Distributes queue ownership among cores so multiple cores handle dispatcher duties.Requires SE Reboot. Field introduced in 17.2.8.")
  public Boolean isDistributeQueues() {
    return distributeQueues;
  }

  public void setDistributeQueues(Boolean distributeQueues) {
    this.distributeQueues = distributeQueues;
  }

  public ServiceEngineGroup distributeVnics(Boolean distributeVnics) {
    this.distributeVnics = distributeVnics;
    return this;
  }

   /**
   * Distributes vnic ownership among cores so multiple cores handle dispatcher duties.Requires SE Reboot. Field introduced in 18.2.5.
   * @return distributeVnics
  **/
  @Schema(description = "Distributes vnic ownership among cores so multiple cores handle dispatcher duties.Requires SE Reboot. Field introduced in 18.2.5.")
  public Boolean isDistributeVnics() {
    return distributeVnics;
  }

  public void setDistributeVnics(Boolean distributeVnics) {
    this.distributeVnics = distributeVnics;
  }

  public ServiceEngineGroup enableGratarpPermanent(Boolean enableGratarpPermanent) {
    this.enableGratarpPermanent = enableGratarpPermanent;
    return this;
  }

   /**
   * Enable GratArp for VIP_IP. Field introduced in 18.2.3.
   * @return enableGratarpPermanent
  **/
  @Schema(description = "Enable GratArp for VIP_IP. Field introduced in 18.2.3.")
  public Boolean isEnableGratarpPermanent() {
    return enableGratarpPermanent;
  }

  public void setEnableGratarpPermanent(Boolean enableGratarpPermanent) {
    this.enableGratarpPermanent = enableGratarpPermanent;
  }

  public ServiceEngineGroup enableHsmPriming(Boolean enableHsmPriming) {
    this.enableHsmPriming = enableHsmPriming;
    return this;
  }

   /**
   * (This is a beta feature). Enable HSM key priming. If enabled, key handles on the hsm will be synced to SE before processing client connections. Field introduced in 17.2.7, 18.1.1.
   * @return enableHsmPriming
  **/
  @Schema(description = "(This is a beta feature). Enable HSM key priming. If enabled, key handles on the hsm will be synced to SE before processing client connections. Field introduced in 17.2.7, 18.1.1.")
  public Boolean isEnableHsmPriming() {
    return enableHsmPriming;
  }

  public void setEnableHsmPriming(Boolean enableHsmPriming) {
    this.enableHsmPriming = enableHsmPriming;
  }

  public ServiceEngineGroup enableMultiLb(Boolean enableMultiLb) {
    this.enableMultiLb = enableMultiLb;
    return this;
  }

   /**
   * Applicable only for Azure cloud with Basic SKU LB. If set, additional Azure LBs will be automatically created if resources in existing LB are exhausted. Field introduced in 17.2.10, 18.1.2.
   * @return enableMultiLb
  **/
  @Schema(description = "Applicable only for Azure cloud with Basic SKU LB. If set, additional Azure LBs will be automatically created if resources in existing LB are exhausted. Field introduced in 17.2.10, 18.1.2.")
  public Boolean isEnableMultiLb() {
    return enableMultiLb;
  }

  public void setEnableMultiLb(Boolean enableMultiLb) {
    this.enableMultiLb = enableMultiLb;
  }

  public ServiceEngineGroup enablePcapTxRing(Boolean enablePcapTxRing) {
    this.enablePcapTxRing = enablePcapTxRing;
    return this;
  }

   /**
   * Enable TX ring support in pcap mode of operation. TSO feature is not supported with TX Ring enabled. Deprecated from 18.2.8, instead use pcap_tx_mode. Requires SE Reboot. Field introduced in 18.2.5.
   * @return enablePcapTxRing
  **/
  @Schema(description = "Enable TX ring support in pcap mode of operation. TSO feature is not supported with TX Ring enabled. Deprecated from 18.2.8, instead use pcap_tx_mode. Requires SE Reboot. Field introduced in 18.2.5.")
  public Boolean isEnablePcapTxRing() {
    return enablePcapTxRing;
  }

  public void setEnablePcapTxRing(Boolean enablePcapTxRing) {
    this.enablePcapTxRing = enablePcapTxRing;
  }

  public ServiceEngineGroup enableRouting(Boolean enableRouting) {
    this.enableRouting = enableRouting;
    return this;
  }

   /**
   * Enable routing for this ServiceEngineGroup . Field deprecated in 18.2.5.
   * @return enableRouting
  **/
  @Schema(description = "Enable routing for this ServiceEngineGroup . Field deprecated in 18.2.5.")
  public Boolean isEnableRouting() {
    return enableRouting;
  }

  public void setEnableRouting(Boolean enableRouting) {
    this.enableRouting = enableRouting;
  }

  public ServiceEngineGroup enableVipOnAllInterfaces(Boolean enableVipOnAllInterfaces) {
    this.enableVipOnAllInterfaces = enableVipOnAllInterfaces;
    return this;
  }

   /**
   * Enable VIP on all interfaces of SE. Field deprecated in 18.2.5. Field introduced in 17.1.1.
   * @return enableVipOnAllInterfaces
  **/
  @Schema(description = "Enable VIP on all interfaces of SE. Field deprecated in 18.2.5. Field introduced in 17.1.1.")
  public Boolean isEnableVipOnAllInterfaces() {
    return enableVipOnAllInterfaces;
  }

  public void setEnableVipOnAllInterfaces(Boolean enableVipOnAllInterfaces) {
    this.enableVipOnAllInterfaces = enableVipOnAllInterfaces;
  }

  public ServiceEngineGroup enableVmac(Boolean enableVmac) {
    this.enableVmac = enableVmac;
    return this;
  }

   /**
   * Use Virtual MAC address for interfaces on which floating interface IPs are placed. Field deprecated in 18.2.5.
   * @return enableVmac
  **/
  @Schema(description = "Use Virtual MAC address for interfaces on which floating interface IPs are placed. Field deprecated in 18.2.5.")
  public Boolean isEnableVmac() {
    return enableVmac;
  }

  public void setEnableVmac(Boolean enableVmac) {
    this.enableVmac = enableVmac;
  }

  public ServiceEngineGroup ephemeralPortrangeEnd(Integer ephemeralPortrangeEnd) {
    this.ephemeralPortrangeEnd = ephemeralPortrangeEnd;
    return this;
  }

   /**
   * End local ephemeral port number for outbound connections. Field introduced in 17.2.13, 18.1.5, 18.2.1.
   * @return ephemeralPortrangeEnd
  **/
  @Schema(description = "End local ephemeral port number for outbound connections. Field introduced in 17.2.13, 18.1.5, 18.2.1.")
  public Integer getEphemeralPortrangeEnd() {
    return ephemeralPortrangeEnd;
  }

  public void setEphemeralPortrangeEnd(Integer ephemeralPortrangeEnd) {
    this.ephemeralPortrangeEnd = ephemeralPortrangeEnd;
  }

  public ServiceEngineGroup ephemeralPortrangeStart(Integer ephemeralPortrangeStart) {
    this.ephemeralPortrangeStart = ephemeralPortrangeStart;
    return this;
  }

   /**
   * Start local ephemeral port number for outbound connections. Field introduced in 17.2.13, 18.1.5, 18.2.1.
   * @return ephemeralPortrangeStart
  **/
  @Schema(description = "Start local ephemeral port number for outbound connections. Field introduced in 17.2.13, 18.1.5, 18.2.1.")
  public Integer getEphemeralPortrangeStart() {
    return ephemeralPortrangeStart;
  }

  public void setEphemeralPortrangeStart(Integer ephemeralPortrangeStart) {
    this.ephemeralPortrangeStart = ephemeralPortrangeStart;
  }

  public ServiceEngineGroup extraConfigMultiplier(Double extraConfigMultiplier) {
    this.extraConfigMultiplier = extraConfigMultiplier;
    return this;
  }

   /**
   * Multiplier for extra config to support large VS/Pool config.
   * @return extraConfigMultiplier
  **/
  @Schema(description = "Multiplier for extra config to support large VS/Pool config.")
  public Double getExtraConfigMultiplier() {
    return extraConfigMultiplier;
  }

  public void setExtraConfigMultiplier(Double extraConfigMultiplier) {
    this.extraConfigMultiplier = extraConfigMultiplier;
  }

  public ServiceEngineGroup extraSharedConfigMemory(Integer extraSharedConfigMemory) {
    this.extraSharedConfigMemory = extraSharedConfigMemory;
    return this;
  }

   /**
   * Extra config memory to support large Geo DB configuration. Field introduced in 17.1.1.
   * @return extraSharedConfigMemory
  **/
  @Schema(description = "Extra config memory to support large Geo DB configuration. Field introduced in 17.1.1.")
  public Integer getExtraSharedConfigMemory() {
    return extraSharedConfigMemory;
  }

  public void setExtraSharedConfigMemory(Integer extraSharedConfigMemory) {
    this.extraSharedConfigMemory = extraSharedConfigMemory;
  }

  public ServiceEngineGroup floatingIntfIp(List<IpAddr> floatingIntfIp) {
    this.floatingIntfIp = floatingIntfIp;
    return this;
  }

  public ServiceEngineGroup addFloatingIntfIpItem(IpAddr floatingIntfIpItem) {
    if (this.floatingIntfIp == null) {
      this.floatingIntfIp = new ArrayList<IpAddr>();
    }
    this.floatingIntfIp.add(floatingIntfIpItem);
    return this;
  }

   /**
   * If ServiceEngineGroup is configured for Legacy 1+1 Active Standby HA Mode, Floating IP&#x27;s will be advertised only by the Active SE in the Pair. Virtual Services in this group must be disabled/enabled for any changes to the Floating IP&#x27;s to take effect. Only active SE hosting VS tagged with Active Standby SE 1 Tag will advertise this floating IP when manual load distribution is enabled. Field deprecated in 18.2.5.
   * @return floatingIntfIp
  **/
  @Schema(description = "If ServiceEngineGroup is configured for Legacy 1+1 Active Standby HA Mode, Floating IP's will be advertised only by the Active SE in the Pair. Virtual Services in this group must be disabled/enabled for any changes to the Floating IP's to take effect. Only active SE hosting VS tagged with Active Standby SE 1 Tag will advertise this floating IP when manual load distribution is enabled. Field deprecated in 18.2.5.")
  public List<IpAddr> getFloatingIntfIp() {
    return floatingIntfIp;
  }

  public void setFloatingIntfIp(List<IpAddr> floatingIntfIp) {
    this.floatingIntfIp = floatingIntfIp;
  }

  public ServiceEngineGroup floatingIntfIpSe2(List<IpAddr> floatingIntfIpSe2) {
    this.floatingIntfIpSe2 = floatingIntfIpSe2;
    return this;
  }

  public ServiceEngineGroup addFloatingIntfIpSe2Item(IpAddr floatingIntfIpSe2Item) {
    if (this.floatingIntfIpSe2 == null) {
      this.floatingIntfIpSe2 = new ArrayList<IpAddr>();
    }
    this.floatingIntfIpSe2.add(floatingIntfIpSe2Item);
    return this;
  }

   /**
   * If ServiceEngineGroup is configured for Legacy 1+1 Active Standby HA Mode, Floating IP&#x27;s will be advertised only by the Active SE in the Pair. Virtual Services in this group must be disabled/enabled for any changes to the Floating IP&#x27;s to take effect. Only active SE hosting VS tagged with Active Standby SE 2 Tag will advertise this floating IP when manual load distribution is enabled. Field deprecated in 18.2.5.
   * @return floatingIntfIpSe2
  **/
  @Schema(description = "If ServiceEngineGroup is configured for Legacy 1+1 Active Standby HA Mode, Floating IP's will be advertised only by the Active SE in the Pair. Virtual Services in this group must be disabled/enabled for any changes to the Floating IP's to take effect. Only active SE hosting VS tagged with Active Standby SE 2 Tag will advertise this floating IP when manual load distribution is enabled. Field deprecated in 18.2.5.")
  public List<IpAddr> getFloatingIntfIpSe2() {
    return floatingIntfIpSe2;
  }

  public void setFloatingIntfIpSe2(List<IpAddr> floatingIntfIpSe2) {
    this.floatingIntfIpSe2 = floatingIntfIpSe2;
  }

  public ServiceEngineGroup flowTableNewSynMaxEntries(Integer flowTableNewSynMaxEntries) {
    this.flowTableNewSynMaxEntries = flowTableNewSynMaxEntries;
    return this;
  }

   /**
   * Maximum number of flow table entries that have not completed TCP three-way handshake yet. Field introduced in 17.2.5.
   * @return flowTableNewSynMaxEntries
  **/
  @Schema(description = "Maximum number of flow table entries that have not completed TCP three-way handshake yet. Field introduced in 17.2.5.")
  public Integer getFlowTableNewSynMaxEntries() {
    return flowTableNewSynMaxEntries;
  }

  public void setFlowTableNewSynMaxEntries(Integer flowTableNewSynMaxEntries) {
    this.flowTableNewSynMaxEntries = flowTableNewSynMaxEntries;
  }

  public ServiceEngineGroup freeListSize(Integer freeListSize) {
    this.freeListSize = freeListSize;
    return this;
  }

   /**
   * Number of entries in the free list. Field introduced in 17.2.10, 18.1.2.
   * @return freeListSize
  **/
  @Schema(description = "Number of entries in the free list. Field introduced in 17.2.10, 18.1.2.")
  public Integer getFreeListSize() {
    return freeListSize;
  }

  public void setFreeListSize(Integer freeListSize) {
    this.freeListSize = freeListSize;
  }

  public ServiceEngineGroup gratarpPermanentPeriodicity(Integer gratarpPermanentPeriodicity) {
    this.gratarpPermanentPeriodicity = gratarpPermanentPeriodicity;
    return this;
  }

   /**
   * GratArp periodicity for VIP-IP. Allowed values are 5-30. Field introduced in 18.2.3.
   * @return gratarpPermanentPeriodicity
  **/
  @Schema(description = "GratArp periodicity for VIP-IP. Allowed values are 5-30. Field introduced in 18.2.3.")
  public Integer getGratarpPermanentPeriodicity() {
    return gratarpPermanentPeriodicity;
  }

  public void setGratarpPermanentPeriodicity(Integer gratarpPermanentPeriodicity) {
    this.gratarpPermanentPeriodicity = gratarpPermanentPeriodicity;
  }

  public ServiceEngineGroup haMode(String haMode) {
    this.haMode = haMode;
    return this;
  }

   /**
   * High Availability mode for all the Virtual Services using this Service Engine group. Enum options - HA_MODE_SHARED_PAIR, HA_MODE_SHARED, HA_MODE_LEGACY_ACTIVE_STANDBY.
   * @return haMode
  **/
  @Schema(description = "High Availability mode for all the Virtual Services using this Service Engine group. Enum options - HA_MODE_SHARED_PAIR, HA_MODE_SHARED, HA_MODE_LEGACY_ACTIVE_STANDBY.")
  public String getHaMode() {
    return haMode;
  }

  public void setHaMode(String haMode) {
    this.haMode = haMode;
  }

  public ServiceEngineGroup hardwaresecuritymodulegroupRef(String hardwaresecuritymodulegroupRef) {
    this.hardwaresecuritymodulegroupRef = hardwaresecuritymodulegroupRef;
    return this;
  }

   /**
   *  It is a reference to an object of type HardwareSecurityModuleGroup.
   * @return hardwaresecuritymodulegroupRef
  **/
  @Schema(description = " It is a reference to an object of type HardwareSecurityModuleGroup.")
  public String getHardwaresecuritymodulegroupRef() {
    return hardwaresecuritymodulegroupRef;
  }

  public void setHardwaresecuritymodulegroupRef(String hardwaresecuritymodulegroupRef) {
    this.hardwaresecuritymodulegroupRef = hardwaresecuritymodulegroupRef;
  }

  public ServiceEngineGroup heapMinimumConfigMemory(Integer heapMinimumConfigMemory) {
    this.heapMinimumConfigMemory = heapMinimumConfigMemory;
    return this;
  }

   /**
   * Minimum required heap memory to apply any configuration. Allowed values are 0-100. Field introduced in 18.1.2.
   * @return heapMinimumConfigMemory
  **/
  @Schema(description = "Minimum required heap memory to apply any configuration. Allowed values are 0-100. Field introduced in 18.1.2.")
  public Integer getHeapMinimumConfigMemory() {
    return heapMinimumConfigMemory;
  }

  public void setHeapMinimumConfigMemory(Integer heapMinimumConfigMemory) {
    this.heapMinimumConfigMemory = heapMinimumConfigMemory;
  }

  public ServiceEngineGroup hmOnStandby(Boolean hmOnStandby) {
    this.hmOnStandby = hmOnStandby;
    return this;
  }

   /**
   * Enable active health monitoring from the standby SE for all placed virtual services.
   * @return hmOnStandby
  **/
  @Schema(description = "Enable active health monitoring from the standby SE for all placed virtual services.")
  public Boolean isHmOnStandby() {
    return hmOnStandby;
  }

  public void setHmOnStandby(Boolean hmOnStandby) {
    this.hmOnStandby = hmOnStandby;
  }

  public ServiceEngineGroup hostAttributeKey(String hostAttributeKey) {
    this.hostAttributeKey = hostAttributeKey;
    return this;
  }

   /**
   * Key of a (Key, Value) pair identifying a label for a set of Nodes usually in Container Clouds. Needs to be specified together with host_attribute_value. SEs can be configured differently including HA modes across different SE Groups. May also be used for isolation between different classes of VirtualServices. VirtualServices&#x27; SE Group may be specified via annotations/labels. A OpenShift/Kubernetes namespace maybe annotated with a matching SE Group label as openshift.io/node-selector  apptype&#x3D;prod. When multiple SE Groups are used in a Cloud with host attributes specified,just a single SE Group can exist as a match-all SE Group without a host_attribute_key.
   * @return hostAttributeKey
  **/
  @Schema(description = "Key of a (Key, Value) pair identifying a label for a set of Nodes usually in Container Clouds. Needs to be specified together with host_attribute_value. SEs can be configured differently including HA modes across different SE Groups. May also be used for isolation between different classes of VirtualServices. VirtualServices' SE Group may be specified via annotations/labels. A OpenShift/Kubernetes namespace maybe annotated with a matching SE Group label as openshift.io/node-selector  apptype=prod. When multiple SE Groups are used in a Cloud with host attributes specified,just a single SE Group can exist as a match-all SE Group without a host_attribute_key.")
  public String getHostAttributeKey() {
    return hostAttributeKey;
  }

  public void setHostAttributeKey(String hostAttributeKey) {
    this.hostAttributeKey = hostAttributeKey;
  }

  public ServiceEngineGroup hostAttributeValue(String hostAttributeValue) {
    this.hostAttributeValue = hostAttributeValue;
    return this;
  }

   /**
   * Value of a (Key, Value) pair identifying a label for a set of Nodes usually in Container Clouds. Needs to be specified together with host_attribute_key.
   * @return hostAttributeValue
  **/
  @Schema(description = "Value of a (Key, Value) pair identifying a label for a set of Nodes usually in Container Clouds. Needs to be specified together with host_attribute_key.")
  public String getHostAttributeValue() {
    return hostAttributeValue;
  }

  public void setHostAttributeValue(String hostAttributeValue) {
    this.hostAttributeValue = hostAttributeValue;
  }

  public ServiceEngineGroup hostGatewayMonitor(Boolean hostGatewayMonitor) {
    this.hostGatewayMonitor = hostGatewayMonitor;
    return this;
  }

   /**
   * Enable the host gateway monitor when service engine is deployed as docker container. Disabled by default. Field introduced in 17.2.4.
   * @return hostGatewayMonitor
  **/
  @Schema(description = "Enable the host gateway monitor when service engine is deployed as docker container. Disabled by default. Field introduced in 17.2.4.")
  public Boolean isHostGatewayMonitor() {
    return hostGatewayMonitor;
  }

  public void setHostGatewayMonitor(Boolean hostGatewayMonitor) {
    this.hostGatewayMonitor = hostGatewayMonitor;
  }

  public ServiceEngineGroup hypervisor(String hypervisor) {
    this.hypervisor = hypervisor;
    return this;
  }

   /**
   * Override default hypervisor. Enum options - DEFAULT, VMWARE_ESX, KVM, VMWARE_VSAN, XEN.
   * @return hypervisor
  **/
  @Schema(description = "Override default hypervisor. Enum options - DEFAULT, VMWARE_ESX, KVM, VMWARE_VSAN, XEN.")
  public String getHypervisor() {
    return hypervisor;
  }

  public void setHypervisor(String hypervisor) {
    this.hypervisor = hypervisor;
  }

  public ServiceEngineGroup ignoreRttThreshold(Integer ignoreRttThreshold) {
    this.ignoreRttThreshold = ignoreRttThreshold;
    return this;
  }

   /**
   * Ignore RTT samples if it is above threshold. Field introduced in 17.1.6,17.2.2.
   * @return ignoreRttThreshold
  **/
  @Schema(description = "Ignore RTT samples if it is above threshold. Field introduced in 17.1.6,17.2.2.")
  public Integer getIgnoreRttThreshold() {
    return ignoreRttThreshold;
  }

  public void setIgnoreRttThreshold(Integer ignoreRttThreshold) {
    this.ignoreRttThreshold = ignoreRttThreshold;
  }

  public ServiceEngineGroup ingressAccessData(String ingressAccessData) {
    this.ingressAccessData = ingressAccessData;
    return this;
  }

   /**
   * Program SE security group ingress rules to allow VIP data access from remote CIDR type. Enum options - SG_INGRESS_ACCESS_NONE, SG_INGRESS_ACCESS_ALL, SG_INGRESS_ACCESS_VPC. Field introduced in 17.1.5.
   * @return ingressAccessData
  **/
  @Schema(description = "Program SE security group ingress rules to allow VIP data access from remote CIDR type. Enum options - SG_INGRESS_ACCESS_NONE, SG_INGRESS_ACCESS_ALL, SG_INGRESS_ACCESS_VPC. Field introduced in 17.1.5.")
  public String getIngressAccessData() {
    return ingressAccessData;
  }

  public void setIngressAccessData(String ingressAccessData) {
    this.ingressAccessData = ingressAccessData;
  }

  public ServiceEngineGroup ingressAccessMgmt(String ingressAccessMgmt) {
    this.ingressAccessMgmt = ingressAccessMgmt;
    return this;
  }

   /**
   * Program SE security group ingress rules to allow SSH/ICMP management access from remote CIDR type. Enum options - SG_INGRESS_ACCESS_NONE, SG_INGRESS_ACCESS_ALL, SG_INGRESS_ACCESS_VPC. Field introduced in 17.1.5.
   * @return ingressAccessMgmt
  **/
  @Schema(description = "Program SE security group ingress rules to allow SSH/ICMP management access from remote CIDR type. Enum options - SG_INGRESS_ACCESS_NONE, SG_INGRESS_ACCESS_ALL, SG_INGRESS_ACCESS_VPC. Field introduced in 17.1.5.")
  public String getIngressAccessMgmt() {
    return ingressAccessMgmt;
  }

  public void setIngressAccessMgmt(String ingressAccessMgmt) {
    this.ingressAccessMgmt = ingressAccessMgmt;
  }

  public ServiceEngineGroup instanceFlavor(String instanceFlavor) {
    this.instanceFlavor = instanceFlavor;
    return this;
  }

   /**
   * Instance/Flavor name for SE instance.
   * @return instanceFlavor
  **/
  @Schema(description = "Instance/Flavor name for SE instance.")
  public String getInstanceFlavor() {
    return instanceFlavor;
  }

  public void setInstanceFlavor(String instanceFlavor) {
    this.instanceFlavor = instanceFlavor;
  }

  public ServiceEngineGroup iptables(List<IptableRuleSet> iptables) {
    this.iptables = iptables;
    return this;
  }

  public ServiceEngineGroup addIptablesItem(IptableRuleSet iptablesItem) {
    if (this.iptables == null) {
      this.iptables = new ArrayList<IptableRuleSet>();
    }
    this.iptables.add(iptablesItem);
    return this;
  }

   /**
   * Iptable Rules.
   * @return iptables
  **/
  @Schema(description = "Iptable Rules.")
  public List<IptableRuleSet> getIptables() {
    return iptables;
  }

  public void setIptables(List<IptableRuleSet> iptables) {
    this.iptables = iptables;
  }

  public ServiceEngineGroup leastLoadCoreSelection(Boolean leastLoadCoreSelection) {
    this.leastLoadCoreSelection = leastLoadCoreSelection;
    return this;
  }

   /**
   * Select core with least load for new flow.
   * @return leastLoadCoreSelection
  **/
  @Schema(description = "Select core with least load for new flow.")
  public Boolean isLeastLoadCoreSelection() {
    return leastLoadCoreSelection;
  }

  public void setLeastLoadCoreSelection(Boolean leastLoadCoreSelection) {
    this.leastLoadCoreSelection = leastLoadCoreSelection;
  }

  public ServiceEngineGroup licenseTier(String licenseTier) {
    this.licenseTier = licenseTier;
    return this;
  }

   /**
   * Specifies the license tier which would be used. This field by default inherits the value from cloud. Enum options - ENTERPRISE_16, ENTERPRISE_18. Field introduced in 17.2.5.
   * @return licenseTier
  **/
  @Schema(description = "Specifies the license tier which would be used. This field by default inherits the value from cloud. Enum options - ENTERPRISE_16, ENTERPRISE_18. Field introduced in 17.2.5.")
  public String getLicenseTier() {
    return licenseTier;
  }

  public void setLicenseTier(String licenseTier) {
    this.licenseTier = licenseTier;
  }

  public ServiceEngineGroup licenseType(String licenseType) {
    this.licenseType = licenseType;
    return this;
  }

   /**
   * If no license type is specified then default license enforcement for the cloud type is chosen. Enum options - LIC_BACKEND_SERVERS, LIC_SOCKETS, LIC_CORES, LIC_HOSTS, LIC_SE_BANDWIDTH, LIC_METERED_SE_BANDWIDTH. Field introduced in 17.2.5.
   * @return licenseType
  **/
  @Schema(description = "If no license type is specified then default license enforcement for the cloud type is chosen. Enum options - LIC_BACKEND_SERVERS, LIC_SOCKETS, LIC_CORES, LIC_HOSTS, LIC_SE_BANDWIDTH, LIC_METERED_SE_BANDWIDTH. Field introduced in 17.2.5.")
  public String getLicenseType() {
    return licenseType;
  }

  public void setLicenseType(String licenseType) {
    this.licenseType = licenseType;
  }

  public ServiceEngineGroup logDisksz(Integer logDisksz) {
    this.logDisksz = logDisksz;
    return this;
  }

   /**
   * Maximum disk capacity (in MB) to be allocated to an SE. This is exclusively used for debug and log data.
   * @return logDisksz
  **/
  @Schema(description = "Maximum disk capacity (in MB) to be allocated to an SE. This is exclusively used for debug and log data.")
  public Integer getLogDisksz() {
    return logDisksz;
  }

  public void setLogDisksz(Integer logDisksz) {
    this.logDisksz = logDisksz;
  }

  public ServiceEngineGroup maxConcurrentExternalHm(Integer maxConcurrentExternalHm) {
    this.maxConcurrentExternalHm = maxConcurrentExternalHm;
    return this;
  }

   /**
   * Maximum number of external health monitors that can run concurrently in a service engine. This helps control the CPU and memory use by external health monitors. Special values are 0- &#x27;Value will be internally calculated based on cpu and memory&#x27;. Field introduced in 18.2.7.
   * @return maxConcurrentExternalHm
  **/
  @Schema(description = "Maximum number of external health monitors that can run concurrently in a service engine. This helps control the CPU and memory use by external health monitors. Special values are 0- 'Value will be internally calculated based on cpu and memory'. Field introduced in 18.2.7.")
  public Integer getMaxConcurrentExternalHm() {
    return maxConcurrentExternalHm;
  }

  public void setMaxConcurrentExternalHm(Integer maxConcurrentExternalHm) {
    this.maxConcurrentExternalHm = maxConcurrentExternalHm;
  }

  public ServiceEngineGroup maxCpuUsage(Integer maxCpuUsage) {
    this.maxCpuUsage = maxCpuUsage;
    return this;
  }

   /**
   * When CPU usage on an SE exceeds this threshold, Virtual Services hosted on this SE may be rebalanced to other SEs to reduce load. A new SE may be created as part of this process. Allowed values are 40-90.
   * @return maxCpuUsage
  **/
  @Schema(description = "When CPU usage on an SE exceeds this threshold, Virtual Services hosted on this SE may be rebalanced to other SEs to reduce load. A new SE may be created as part of this process. Allowed values are 40-90.")
  public Integer getMaxCpuUsage() {
    return maxCpuUsage;
  }

  public void setMaxCpuUsage(Integer maxCpuUsage) {
    this.maxCpuUsage = maxCpuUsage;
  }

  public ServiceEngineGroup maxMemoryPerMempool(Integer maxMemoryPerMempool) {
    this.maxMemoryPerMempool = maxMemoryPerMempool;
    return this;
  }

   /**
   * Max bytes that can be allocated in a single mempool. Field introduced in 18.1.5.
   * @return maxMemoryPerMempool
  **/
  @Schema(description = "Max bytes that can be allocated in a single mempool. Field introduced in 18.1.5.")
  public Integer getMaxMemoryPerMempool() {
    return maxMemoryPerMempool;
  }

  public void setMaxMemoryPerMempool(Integer maxMemoryPerMempool) {
    this.maxMemoryPerMempool = maxMemoryPerMempool;
  }

  public ServiceEngineGroup maxNumSeDps(Integer maxNumSeDps) {
    this.maxNumSeDps = maxNumSeDps;
    return this;
  }

   /**
   * Configures the maximum number of se_dp processes created on the SE, requires SE reboot. If not configured, defaults to the number of CPUs on the SE. This should only be used if user wants to limit the number of se_dps to less than the available CPUs on the SE. Field introduced in 20.1.1.
   * @return maxNumSeDps
  **/
  @Schema(description = "Configures the maximum number of se_dp processes created on the SE, requires SE reboot. If not configured, defaults to the number of CPUs on the SE. This should only be used if user wants to limit the number of se_dps to less than the available CPUs on the SE. Field introduced in 20.1.1.")
  public Integer getMaxNumSeDps() {
    return maxNumSeDps;
  }

  public void setMaxNumSeDps(Integer maxNumSeDps) {
    this.maxNumSeDps = maxNumSeDps;
  }

  public ServiceEngineGroup maxPublicIpsPerLb(Integer maxPublicIpsPerLb) {
    this.maxPublicIpsPerLb = maxPublicIpsPerLb;
    return this;
  }

   /**
   * Applicable to Azure platform only. Maximum number of public IPs per Azure LB. . Field introduced in 17.2.12, 18.1.2.
   * @return maxPublicIpsPerLb
  **/
  @Schema(description = "Applicable to Azure platform only. Maximum number of public IPs per Azure LB. . Field introduced in 17.2.12, 18.1.2.")
  public Integer getMaxPublicIpsPerLb() {
    return maxPublicIpsPerLb;
  }

  public void setMaxPublicIpsPerLb(Integer maxPublicIpsPerLb) {
    this.maxPublicIpsPerLb = maxPublicIpsPerLb;
  }

  public ServiceEngineGroup maxQueuesPerVnic(Integer maxQueuesPerVnic) {
    this.maxQueuesPerVnic = maxQueuesPerVnic;
    return this;
  }

   /**
   * Maximum number of queues per vnic Setting to &#x27;0&#x27; utilises all queues that are distributed across dispatcher cores. Allowed values are 0,1,2,4,8,16. Field introduced in 18.2.7, 20.1.1.
   * @return maxQueuesPerVnic
  **/
  @Schema(description = "Maximum number of queues per vnic Setting to '0' utilises all queues that are distributed across dispatcher cores. Allowed values are 0,1,2,4,8,16. Field introduced in 18.2.7, 20.1.1.")
  public Integer getMaxQueuesPerVnic() {
    return maxQueuesPerVnic;
  }

  public void setMaxQueuesPerVnic(Integer maxQueuesPerVnic) {
    this.maxQueuesPerVnic = maxQueuesPerVnic;
  }

  public ServiceEngineGroup maxRulesPerLb(Integer maxRulesPerLb) {
    this.maxRulesPerLb = maxRulesPerLb;
    return this;
  }

   /**
   * Applicable to Azure platform only. Maximum number of rules per Azure LB. . Field introduced in 17.2.12, 18.1.2.
   * @return maxRulesPerLb
  **/
  @Schema(description = "Applicable to Azure platform only. Maximum number of rules per Azure LB. . Field introduced in 17.2.12, 18.1.2.")
  public Integer getMaxRulesPerLb() {
    return maxRulesPerLb;
  }

  public void setMaxRulesPerLb(Integer maxRulesPerLb) {
    this.maxRulesPerLb = maxRulesPerLb;
  }

  public ServiceEngineGroup maxScaleoutPerVs(Integer maxScaleoutPerVs) {
    this.maxScaleoutPerVs = maxScaleoutPerVs;
    return this;
  }

   /**
   * Maximum number of active Service Engines for the Virtual Service. Allowed values are 1-64.
   * @return maxScaleoutPerVs
  **/
  @Schema(description = "Maximum number of active Service Engines for the Virtual Service. Allowed values are 1-64.")
  public Integer getMaxScaleoutPerVs() {
    return maxScaleoutPerVs;
  }

  public void setMaxScaleoutPerVs(Integer maxScaleoutPerVs) {
    this.maxScaleoutPerVs = maxScaleoutPerVs;
  }

  public ServiceEngineGroup maxSe(Integer maxSe) {
    this.maxSe = maxSe;
    return this;
  }

   /**
   * Maximum number of Services Engines in this group. Allowed values are 0-1000.
   * @return maxSe
  **/
  @Schema(description = "Maximum number of Services Engines in this group. Allowed values are 0-1000.")
  public Integer getMaxSe() {
    return maxSe;
  }

  public void setMaxSe(Integer maxSe) {
    this.maxSe = maxSe;
  }

  public ServiceEngineGroup maxVsPerSe(Integer maxVsPerSe) {
    this.maxVsPerSe = maxVsPerSe;
    return this;
  }

   /**
   * Maximum number of Virtual Services that can be placed on a single Service Engine. East West Virtual Services are excluded from this limit. Allowed values are 1-1000.
   * @return maxVsPerSe
  **/
  @Schema(description = "Maximum number of Virtual Services that can be placed on a single Service Engine. East West Virtual Services are excluded from this limit. Allowed values are 1-1000.")
  public Integer getMaxVsPerSe() {
    return maxVsPerSe;
  }

  public void setMaxVsPerSe(Integer maxVsPerSe) {
    this.maxVsPerSe = maxVsPerSe;
  }

  public ServiceEngineGroup memReserve(Boolean memReserve) {
    this.memReserve = memReserve;
    return this;
  }

   /**
   * Placeholder for description of property mem_reserve of obj type ServiceEngineGroup field type str  type boolean
   * @return memReserve
  **/
  @Schema(description = "Placeholder for description of property mem_reserve of obj type ServiceEngineGroup field type str  type boolean")
  public Boolean isMemReserve() {
    return memReserve;
  }

  public void setMemReserve(Boolean memReserve) {
    this.memReserve = memReserve;
  }

  public ServiceEngineGroup memoryForConfigUpdate(Integer memoryForConfigUpdate) {
    this.memoryForConfigUpdate = memoryForConfigUpdate;
    return this;
  }

   /**
   * Indicates the percent of memory reserved for config updates. Allowed values are 0-100. Field introduced in 18.1.2.
   * @return memoryForConfigUpdate
  **/
  @Schema(description = "Indicates the percent of memory reserved for config updates. Allowed values are 0-100. Field introduced in 18.1.2.")
  public Integer getMemoryForConfigUpdate() {
    return memoryForConfigUpdate;
  }

  public void setMemoryForConfigUpdate(Integer memoryForConfigUpdate) {
    this.memoryForConfigUpdate = memoryForConfigUpdate;
  }

  public ServiceEngineGroup memoryPerSe(Integer memoryPerSe) {
    this.memoryPerSe = memoryPerSe;
    return this;
  }

   /**
   * Amount of memory for each of the Service Engine virtual machines.
   * @return memoryPerSe
  **/
  @Schema(description = "Amount of memory for each of the Service Engine virtual machines.")
  public Integer getMemoryPerSe() {
    return memoryPerSe;
  }

  public void setMemoryPerSe(Integer memoryPerSe) {
    this.memoryPerSe = memoryPerSe;
  }

  public ServiceEngineGroup mgmtNetworkRef(String mgmtNetworkRef) {
    this.mgmtNetworkRef = mgmtNetworkRef;
    return this;
  }

   /**
   * Management network to use for Avi Service Engines. It is a reference to an object of type Network.
   * @return mgmtNetworkRef
  **/
  @Schema(description = "Management network to use for Avi Service Engines. It is a reference to an object of type Network.")
  public String getMgmtNetworkRef() {
    return mgmtNetworkRef;
  }

  public void setMgmtNetworkRef(String mgmtNetworkRef) {
    this.mgmtNetworkRef = mgmtNetworkRef;
  }

  public ServiceEngineGroup mgmtSubnet(IpAddrPrefix mgmtSubnet) {
    this.mgmtSubnet = mgmtSubnet;
    return this;
  }

   /**
   * Get mgmtSubnet
   * @return mgmtSubnet
  **/
  @Schema(description = "")
  public IpAddrPrefix getMgmtSubnet() {
    return mgmtSubnet;
  }

  public void setMgmtSubnet(IpAddrPrefix mgmtSubnet) {
    this.mgmtSubnet = mgmtSubnet;
  }

  public ServiceEngineGroup minCpuUsage(Integer minCpuUsage) {
    this.minCpuUsage = minCpuUsage;
    return this;
  }

   /**
   * When CPU usage on an SE falls below the minimum threshold, Virtual Services hosted on the SE may be consolidated onto other underutilized SEs. After consolidation, unused Service Engines may then be eligible for deletion. . Allowed values are 20-60.
   * @return minCpuUsage
  **/
  @Schema(description = "When CPU usage on an SE falls below the minimum threshold, Virtual Services hosted on the SE may be consolidated onto other underutilized SEs. After consolidation, unused Service Engines may then be eligible for deletion. . Allowed values are 20-60.")
  public Integer getMinCpuUsage() {
    return minCpuUsage;
  }

  public void setMinCpuUsage(Integer minCpuUsage) {
    this.minCpuUsage = minCpuUsage;
  }

  public ServiceEngineGroup minScaleoutPerVs(Integer minScaleoutPerVs) {
    this.minScaleoutPerVs = minScaleoutPerVs;
    return this;
  }

   /**
   * Minimum number of active Service Engines for the Virtual Service. Allowed values are 1-64.
   * @return minScaleoutPerVs
  **/
  @Schema(description = "Minimum number of active Service Engines for the Virtual Service. Allowed values are 1-64.")
  public Integer getMinScaleoutPerVs() {
    return minScaleoutPerVs;
  }

  public void setMinScaleoutPerVs(Integer minScaleoutPerVs) {
    this.minScaleoutPerVs = minScaleoutPerVs;
  }

  public ServiceEngineGroup minSe(Integer minSe) {
    this.minSe = minSe;
    return this;
  }

   /**
   * Minimum number of Services Engines in this group (relevant for SE AutoRebalance only). Allowed values are 0-1000. Field introduced in 17.2.13,18.1.3,18.2.1.
   * @return minSe
  **/
  @Schema(description = "Minimum number of Services Engines in this group (relevant for SE AutoRebalance only). Allowed values are 0-1000. Field introduced in 17.2.13,18.1.3,18.2.1.")
  public Integer getMinSe() {
    return minSe;
  }

  public void setMinSe(Integer minSe) {
    this.minSe = minSe;
  }

  public ServiceEngineGroup minimumConnectionMemory(Integer minimumConnectionMemory) {
    this.minimumConnectionMemory = minimumConnectionMemory;
    return this;
  }

   /**
   * Indicates the percent of memory reserved for connections. Allowed values are 0-100. Field introduced in 18.1.2.
   * @return minimumConnectionMemory
  **/
  @Schema(description = "Indicates the percent of memory reserved for connections. Allowed values are 0-100. Field introduced in 18.1.2.")
  public Integer getMinimumConnectionMemory() {
    return minimumConnectionMemory;
  }

  public void setMinimumConnectionMemory(Integer minimumConnectionMemory) {
    this.minimumConnectionMemory = minimumConnectionMemory;
  }

  public ServiceEngineGroup minimumRequiredConfigMemory(Integer minimumRequiredConfigMemory) {
    this.minimumRequiredConfigMemory = minimumRequiredConfigMemory;
    return this;
  }

   /**
   * Required available config memory to apply any configuration. Allowed values are 0-90. Field deprecated in 18.1.2. Field introduced in 18.1.1.
   * @return minimumRequiredConfigMemory
  **/
  @Schema(description = "Required available config memory to apply any configuration. Allowed values are 0-90. Field deprecated in 18.1.2. Field introduced in 18.1.1.")
  public Integer getMinimumRequiredConfigMemory() {
    return minimumRequiredConfigMemory;
  }

  public void setMinimumRequiredConfigMemory(Integer minimumRequiredConfigMemory) {
    this.minimumRequiredConfigMemory = minimumRequiredConfigMemory;
  }

  public ServiceEngineGroup nLogStreamingThreads(Integer nLogStreamingThreads) {
    this.nLogStreamingThreads = nLogStreamingThreads;
    return this;
  }

   /**
   * Number of threads to use for log streaming. Allowed values are 1-100. Field introduced in 17.2.12, 18.1.2.
   * @return nLogStreamingThreads
  **/
  @Schema(description = "Number of threads to use for log streaming. Allowed values are 1-100. Field introduced in 17.2.12, 18.1.2.")
  public Integer getNLogStreamingThreads() {
    return nLogStreamingThreads;
  }

  public void setNLogStreamingThreads(Integer nLogStreamingThreads) {
    this.nLogStreamingThreads = nLogStreamingThreads;
  }

  public ServiceEngineGroup name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the object.
   * @return name
  **/
  @Schema(required = true, description = "Name of the object.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public ServiceEngineGroup natFlowTcpClosedTimeout(Integer natFlowTcpClosedTimeout) {
    this.natFlowTcpClosedTimeout = natFlowTcpClosedTimeout;
    return this;
  }

   /**
   * Idle timeout in seconds for nat tcp flows in closed state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.
   * @return natFlowTcpClosedTimeout
  **/
  @Schema(description = "Idle timeout in seconds for nat tcp flows in closed state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.")
  public Integer getNatFlowTcpClosedTimeout() {
    return natFlowTcpClosedTimeout;
  }

  public void setNatFlowTcpClosedTimeout(Integer natFlowTcpClosedTimeout) {
    this.natFlowTcpClosedTimeout = natFlowTcpClosedTimeout;
  }

  public ServiceEngineGroup natFlowTcpEstablishedTimeout(Integer natFlowTcpEstablishedTimeout) {
    this.natFlowTcpEstablishedTimeout = natFlowTcpEstablishedTimeout;
    return this;
  }

   /**
   * Idle timeout in seconds for nat tcp flows in established state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.
   * @return natFlowTcpEstablishedTimeout
  **/
  @Schema(description = "Idle timeout in seconds for nat tcp flows in established state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.")
  public Integer getNatFlowTcpEstablishedTimeout() {
    return natFlowTcpEstablishedTimeout;
  }

  public void setNatFlowTcpEstablishedTimeout(Integer natFlowTcpEstablishedTimeout) {
    this.natFlowTcpEstablishedTimeout = natFlowTcpEstablishedTimeout;
  }

  public ServiceEngineGroup natFlowTcpHalfClosedTimeout(Integer natFlowTcpHalfClosedTimeout) {
    this.natFlowTcpHalfClosedTimeout = natFlowTcpHalfClosedTimeout;
    return this;
  }

   /**
   * Idle timeout in seconds for nat tcp flows in half closed state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.
   * @return natFlowTcpHalfClosedTimeout
  **/
  @Schema(description = "Idle timeout in seconds for nat tcp flows in half closed state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.")
  public Integer getNatFlowTcpHalfClosedTimeout() {
    return natFlowTcpHalfClosedTimeout;
  }

  public void setNatFlowTcpHalfClosedTimeout(Integer natFlowTcpHalfClosedTimeout) {
    this.natFlowTcpHalfClosedTimeout = natFlowTcpHalfClosedTimeout;
  }

  public ServiceEngineGroup natFlowTcpHandshakeTimeout(Integer natFlowTcpHandshakeTimeout) {
    this.natFlowTcpHandshakeTimeout = natFlowTcpHandshakeTimeout;
    return this;
  }

   /**
   * Idle timeout in seconds for nat tcp flows in handshake state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.
   * @return natFlowTcpHandshakeTimeout
  **/
  @Schema(description = "Idle timeout in seconds for nat tcp flows in handshake state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.")
  public Integer getNatFlowTcpHandshakeTimeout() {
    return natFlowTcpHandshakeTimeout;
  }

  public void setNatFlowTcpHandshakeTimeout(Integer natFlowTcpHandshakeTimeout) {
    this.natFlowTcpHandshakeTimeout = natFlowTcpHandshakeTimeout;
  }

  public ServiceEngineGroup natFlowUdpNoresponseTimeout(Integer natFlowUdpNoresponseTimeout) {
    this.natFlowUdpNoresponseTimeout = natFlowUdpNoresponseTimeout;
    return this;
  }

   /**
   * Idle timeout in seconds for nat udp flows in noresponse state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.
   * @return natFlowUdpNoresponseTimeout
  **/
  @Schema(description = "Idle timeout in seconds for nat udp flows in noresponse state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.")
  public Integer getNatFlowUdpNoresponseTimeout() {
    return natFlowUdpNoresponseTimeout;
  }

  public void setNatFlowUdpNoresponseTimeout(Integer natFlowUdpNoresponseTimeout) {
    this.natFlowUdpNoresponseTimeout = natFlowUdpNoresponseTimeout;
  }

  public ServiceEngineGroup natFlowUdpResponseTimeout(Integer natFlowUdpResponseTimeout) {
    this.natFlowUdpResponseTimeout = natFlowUdpResponseTimeout;
    return this;
  }

   /**
   * Idle timeout in seconds for nat udp flows in response state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.
   * @return natFlowUdpResponseTimeout
  **/
  @Schema(description = "Idle timeout in seconds for nat udp flows in response state. Allowed values are 1-3600. Field deprecated in 18.2.5. Field introduced in 18.2.5.")
  public Integer getNatFlowUdpResponseTimeout() {
    return natFlowUdpResponseTimeout;
  }

  public void setNatFlowUdpResponseTimeout(Integer natFlowUdpResponseTimeout) {
    this.natFlowUdpResponseTimeout = natFlowUdpResponseTimeout;
  }

  public ServiceEngineGroup nonSignificantLogThrottle(Integer nonSignificantLogThrottle) {
    this.nonSignificantLogThrottle = nonSignificantLogThrottle;
    return this;
  }

   /**
   * This setting limits the number of non-significant logs generated per second per core on this SE. Default is 100 logs per second. Set it to zero (0) to disable throttling. Field introduced in 17.1.3.
   * @return nonSignificantLogThrottle
  **/
  @Schema(description = "This setting limits the number of non-significant logs generated per second per core on this SE. Default is 100 logs per second. Set it to zero (0) to disable throttling. Field introduced in 17.1.3.")
  public Integer getNonSignificantLogThrottle() {
    return nonSignificantLogThrottle;
  }

  public void setNonSignificantLogThrottle(Integer nonSignificantLogThrottle) {
    this.nonSignificantLogThrottle = nonSignificantLogThrottle;
  }

  public ServiceEngineGroup numDispatcherCores(Integer numDispatcherCores) {
    this.numDispatcherCores = numDispatcherCores;
    return this;
  }

   /**
   * Number of dispatcher cores (0,1,2,4,8 or 16). If set to 0, then number of dispatcher cores is deduced automatically.Requires SE Reboot. Allowed values are 0,1,2,4,8,16. Field introduced in 17.2.12, 18.1.3, 18.2.1.
   * @return numDispatcherCores
  **/
  @Schema(description = "Number of dispatcher cores (0,1,2,4,8 or 16). If set to 0, then number of dispatcher cores is deduced automatically.Requires SE Reboot. Allowed values are 0,1,2,4,8,16. Field introduced in 17.2.12, 18.1.3, 18.2.1.")
  public Integer getNumDispatcherCores() {
    return numDispatcherCores;
  }

  public void setNumDispatcherCores(Integer numDispatcherCores) {
    this.numDispatcherCores = numDispatcherCores;
  }

  public ServiceEngineGroup numFlowCoresSumChangesToIgnore(Integer numFlowCoresSumChangesToIgnore) {
    this.numFlowCoresSumChangesToIgnore = numFlowCoresSumChangesToIgnore;
    return this;
  }

   /**
   * Number of changes in num flow cores sum to ignore.
   * @return numFlowCoresSumChangesToIgnore
  **/
  @Schema(description = "Number of changes in num flow cores sum to ignore.")
  public Integer getNumFlowCoresSumChangesToIgnore() {
    return numFlowCoresSumChangesToIgnore;
  }

  public void setNumFlowCoresSumChangesToIgnore(Integer numFlowCoresSumChangesToIgnore) {
    this.numFlowCoresSumChangesToIgnore = numFlowCoresSumChangesToIgnore;
  }

  public ServiceEngineGroup openstackAvailabilityZone(String openstackAvailabilityZone) {
    this.openstackAvailabilityZone = openstackAvailabilityZone;
    return this;
  }

   /**
   *  Field deprecated in 17.1.1.
   * @return openstackAvailabilityZone
  **/
  @Schema(description = " Field deprecated in 17.1.1.")
  public String getOpenstackAvailabilityZone() {
    return openstackAvailabilityZone;
  }

  public void setOpenstackAvailabilityZone(String openstackAvailabilityZone) {
    this.openstackAvailabilityZone = openstackAvailabilityZone;
  }

  public ServiceEngineGroup openstackAvailabilityZones(List<String> openstackAvailabilityZones) {
    this.openstackAvailabilityZones = openstackAvailabilityZones;
    return this;
  }

  public ServiceEngineGroup addOpenstackAvailabilityZonesItem(String openstackAvailabilityZonesItem) {
    if (this.openstackAvailabilityZones == null) {
      this.openstackAvailabilityZones = new ArrayList<String>();
    }
    this.openstackAvailabilityZones.add(openstackAvailabilityZonesItem);
    return this;
  }

   /**
   *  Field introduced in 17.1.1.
   * @return openstackAvailabilityZones
  **/
  @Schema(description = " Field introduced in 17.1.1.")
  public List<String> getOpenstackAvailabilityZones() {
    return openstackAvailabilityZones;
  }

  public void setOpenstackAvailabilityZones(List<String> openstackAvailabilityZones) {
    this.openstackAvailabilityZones = openstackAvailabilityZones;
  }

  public ServiceEngineGroup openstackMgmtNetworkName(String openstackMgmtNetworkName) {
    this.openstackMgmtNetworkName = openstackMgmtNetworkName;
    return this;
  }

   /**
   * Avi Management network name.
   * @return openstackMgmtNetworkName
  **/
  @Schema(description = "Avi Management network name.")
  public String getOpenstackMgmtNetworkName() {
    return openstackMgmtNetworkName;
  }

  public void setOpenstackMgmtNetworkName(String openstackMgmtNetworkName) {
    this.openstackMgmtNetworkName = openstackMgmtNetworkName;
  }

  public ServiceEngineGroup openstackMgmtNetworkUuid(String openstackMgmtNetworkUuid) {
    this.openstackMgmtNetworkUuid = openstackMgmtNetworkUuid;
    return this;
  }

   /**
   * Management network UUID.
   * @return openstackMgmtNetworkUuid
  **/
  @Schema(description = "Management network UUID.")
  public String getOpenstackMgmtNetworkUuid() {
    return openstackMgmtNetworkUuid;
  }

  public void setOpenstackMgmtNetworkUuid(String openstackMgmtNetworkUuid) {
    this.openstackMgmtNetworkUuid = openstackMgmtNetworkUuid;
  }

  public ServiceEngineGroup osReservedMemory(Integer osReservedMemory) {
    this.osReservedMemory = osReservedMemory;
    return this;
  }

   /**
   * Amount of extra memory to be reserved for use by the Operating System on a Service Engine.
   * @return osReservedMemory
  **/
  @Schema(description = "Amount of extra memory to be reserved for use by the Operating System on a Service Engine.")
  public Integer getOsReservedMemory() {
    return osReservedMemory;
  }

  public void setOsReservedMemory(Integer osReservedMemory) {
    this.osReservedMemory = osReservedMemory;
  }

  public ServiceEngineGroup pcapTxMode(String pcapTxMode) {
    this.pcapTxMode = pcapTxMode;
    return this;
  }

   /**
   * Determines the PCAP transmit mode of operation. Requires SE Reboot. Enum options - PCAP_TX_AUTO, PCAP_TX_SOCKET, PCAP_TX_RING. Field introduced in 18.2.8, 20.1.1.
   * @return pcapTxMode
  **/
  @Schema(description = "Determines the PCAP transmit mode of operation. Requires SE Reboot. Enum options - PCAP_TX_AUTO, PCAP_TX_SOCKET, PCAP_TX_RING. Field introduced in 18.2.8, 20.1.1.")
  public String getPcapTxMode() {
    return pcapTxMode;
  }

  public void setPcapTxMode(String pcapTxMode) {
    this.pcapTxMode = pcapTxMode;
  }

  public ServiceEngineGroup perApp(Boolean perApp) {
    this.perApp = perApp;
    return this;
  }

   /**
   * Per-app SE mode is designed for deploying dedicated load balancers per app (VS). In this mode, each SE is limited to a max of 2 VSs. vCPUs in per-app SEs count towards licensing usage at 25% rate.
   * @return perApp
  **/
  @Schema(description = "Per-app SE mode is designed for deploying dedicated load balancers per app (VS). In this mode, each SE is limited to a max of 2 VSs. vCPUs in per-app SEs count towards licensing usage at 25% rate.")
  public Boolean isPerApp() {
    return perApp;
  }

  public void setPerApp(Boolean perApp) {
    this.perApp = perApp;
  }

  public ServiceEngineGroup placementMode(String placementMode) {
    this.placementMode = placementMode;
    return this;
  }

   /**
   * If placement mode is &#x27;Auto&#x27;, Virtual Services are automatically placed on Service Engines. Enum options - PLACEMENT_MODE_AUTO.
   * @return placementMode
  **/
  @Schema(description = "If placement mode is 'Auto', Virtual Services are automatically placed on Service Engines. Enum options - PLACEMENT_MODE_AUTO.")
  public String getPlacementMode() {
    return placementMode;
  }

  public void setPlacementMode(String placementMode) {
    this.placementMode = placementMode;
  }

  public ServiceEngineGroup realtimeSeMetrics(MetricsRealTimeUpdate realtimeSeMetrics) {
    this.realtimeSeMetrics = realtimeSeMetrics;
    return this;
  }

   /**
   * Get realtimeSeMetrics
   * @return realtimeSeMetrics
  **/
  @Schema(description = "")
  public MetricsRealTimeUpdate getRealtimeSeMetrics() {
    return realtimeSeMetrics;
  }

  public void setRealtimeSeMetrics(MetricsRealTimeUpdate realtimeSeMetrics) {
    this.realtimeSeMetrics = realtimeSeMetrics;
  }

  public ServiceEngineGroup rebootOnPanic(Boolean rebootOnPanic) {
    this.rebootOnPanic = rebootOnPanic;
    return this;
  }

   /**
   * Reboot the VM or host on kernel panic. Field introduced in 18.2.5.
   * @return rebootOnPanic
  **/
  @Schema(description = "Reboot the VM or host on kernel panic. Field introduced in 18.2.5.")
  public Boolean isRebootOnPanic() {
    return rebootOnPanic;
  }

  public void setRebootOnPanic(Boolean rebootOnPanic) {
    this.rebootOnPanic = rebootOnPanic;
  }

  public ServiceEngineGroup rebootOnStop(Boolean rebootOnStop) {
    this.rebootOnStop = rebootOnStop;
    return this;
  }

   /**
   * Reboot the system if the SE is stopped. Field deprecated in 18.2.5.
   * @return rebootOnStop
  **/
  @Schema(description = "Reboot the system if the SE is stopped. Field deprecated in 18.2.5.")
  public Boolean isRebootOnStop() {
    return rebootOnStop;
  }

  public void setRebootOnStop(Boolean rebootOnStop) {
    this.rebootOnStop = rebootOnStop;
  }

  public ServiceEngineGroup seBandwidthType(String seBandwidthType) {
    this.seBandwidthType = seBandwidthType;
    return this;
  }

   /**
   * Select the SE bandwidth for the bandwidth license. Enum options - SE_BANDWIDTH_UNLIMITED, SE_BANDWIDTH_25M, SE_BANDWIDTH_200M, SE_BANDWIDTH_1000M, SE_BANDWIDTH_10000M. Field introduced in 17.2.5.
   * @return seBandwidthType
  **/
  @Schema(description = "Select the SE bandwidth for the bandwidth license. Enum options - SE_BANDWIDTH_UNLIMITED, SE_BANDWIDTH_25M, SE_BANDWIDTH_200M, SE_BANDWIDTH_1000M, SE_BANDWIDTH_10000M. Field introduced in 17.2.5.")
  public String getSeBandwidthType() {
    return seBandwidthType;
  }

  public void setSeBandwidthType(String seBandwidthType) {
    this.seBandwidthType = seBandwidthType;
  }

  public ServiceEngineGroup seDeprovisionDelay(Integer seDeprovisionDelay) {
    this.seDeprovisionDelay = seDeprovisionDelay;
    return this;
  }

   /**
   * Duration to preserve unused Service Engine virtual machines before deleting them. If traffic to a Virtual Service were to spike up abruptly, this SE would still be available to be utilized again rather than creating a new SE. If this value is set to 0, Controller will never delete any SEs and administrator has to manually cleanup unused SEs. Allowed values are 0-525600.
   * @return seDeprovisionDelay
  **/
  @Schema(description = "Duration to preserve unused Service Engine virtual machines before deleting them. If traffic to a Virtual Service were to spike up abruptly, this SE would still be available to be utilized again rather than creating a new SE. If this value is set to 0, Controller will never delete any SEs and administrator has to manually cleanup unused SEs. Allowed values are 0-525600.")
  public Integer getSeDeprovisionDelay() {
    return seDeprovisionDelay;
  }

  public void setSeDeprovisionDelay(Integer seDeprovisionDelay) {
    this.seDeprovisionDelay = seDeprovisionDelay;
  }

  public ServiceEngineGroup seDosProfile(DosThresholdProfile seDosProfile) {
    this.seDosProfile = seDosProfile;
    return this;
  }

   /**
   * Get seDosProfile
   * @return seDosProfile
  **/
  @Schema(description = "")
  public DosThresholdProfile getSeDosProfile() {
    return seDosProfile;
  }

  public void setSeDosProfile(DosThresholdProfile seDosProfile) {
    this.seDosProfile = seDosProfile;
  }

  public ServiceEngineGroup seDpMaxHbVersion(Integer seDpMaxHbVersion) {
    this.seDpMaxHbVersion = seDpMaxHbVersion;
    return this;
  }

   /**
   * The highest supported SE-SE Heartbeat protocol version. This version is reported by Secondary SE to Primary SE in Heartbeat response messages. Allowed values are 1-2. Field introduced in 20.1.1.
   * @return seDpMaxHbVersion
  **/
  @Schema(description = "The highest supported SE-SE Heartbeat protocol version. This version is reported by Secondary SE to Primary SE in Heartbeat response messages. Allowed values are 1-2. Field introduced in 20.1.1.")
  public Integer getSeDpMaxHbVersion() {
    return seDpMaxHbVersion;
  }

  public void setSeDpMaxHbVersion(Integer seDpMaxHbVersion) {
    this.seDpMaxHbVersion = seDpMaxHbVersion;
  }

  public ServiceEngineGroup seDpVnicQueueStallEventSleep(Integer seDpVnicQueueStallEventSleep) {
    this.seDpVnicQueueStallEventSleep = seDpVnicQueueStallEventSleep;
    return this;
  }

   /**
   * Time (in seconds) service engine waits for after generating a Vnic transmit queue stall event before resetting theNIC. Field introduced in 18.2.5.
   * @return seDpVnicQueueStallEventSleep
  **/
  @Schema(description = "Time (in seconds) service engine waits for after generating a Vnic transmit queue stall event before resetting theNIC. Field introduced in 18.2.5.")
  public Integer getSeDpVnicQueueStallEventSleep() {
    return seDpVnicQueueStallEventSleep;
  }

  public void setSeDpVnicQueueStallEventSleep(Integer seDpVnicQueueStallEventSleep) {
    this.seDpVnicQueueStallEventSleep = seDpVnicQueueStallEventSleep;
  }

  public ServiceEngineGroup seDpVnicQueueStallThreshold(Integer seDpVnicQueueStallThreshold) {
    this.seDpVnicQueueStallThreshold = seDpVnicQueueStallThreshold;
    return this;
  }

   /**
   * Number of consecutive transmit failures to look for before generating a Vnic transmit queue stall event. Field introduced in 18.2.5.
   * @return seDpVnicQueueStallThreshold
  **/
  @Schema(description = "Number of consecutive transmit failures to look for before generating a Vnic transmit queue stall event. Field introduced in 18.2.5.")
  public Integer getSeDpVnicQueueStallThreshold() {
    return seDpVnicQueueStallThreshold;
  }

  public void setSeDpVnicQueueStallThreshold(Integer seDpVnicQueueStallThreshold) {
    this.seDpVnicQueueStallThreshold = seDpVnicQueueStallThreshold;
  }

  public ServiceEngineGroup seDpVnicQueueStallTimeout(Integer seDpVnicQueueStallTimeout) {
    this.seDpVnicQueueStallTimeout = seDpVnicQueueStallTimeout;
    return this;
  }

   /**
   * Time (in milliseconds) to wait for network/NIC recovery on detecting a transmit queue stall after which service engine resets the NIC. Field introduced in 18.2.5.
   * @return seDpVnicQueueStallTimeout
  **/
  @Schema(description = "Time (in milliseconds) to wait for network/NIC recovery on detecting a transmit queue stall after which service engine resets the NIC. Field introduced in 18.2.5.")
  public Integer getSeDpVnicQueueStallTimeout() {
    return seDpVnicQueueStallTimeout;
  }

  public void setSeDpVnicQueueStallTimeout(Integer seDpVnicQueueStallTimeout) {
    this.seDpVnicQueueStallTimeout = seDpVnicQueueStallTimeout;
  }

  public ServiceEngineGroup seDpVnicRestartOnQueueStallCount(Integer seDpVnicRestartOnQueueStallCount) {
    this.seDpVnicRestartOnQueueStallCount = seDpVnicRestartOnQueueStallCount;
    return this;
  }

   /**
   * Number of consecutive transmit queue stall events in se_dp_vnic_stall_se_restart_window to look for before restarting SE. Field introduced in 18.2.5.
   * @return seDpVnicRestartOnQueueStallCount
  **/
  @Schema(description = "Number of consecutive transmit queue stall events in se_dp_vnic_stall_se_restart_window to look for before restarting SE. Field introduced in 18.2.5.")
  public Integer getSeDpVnicRestartOnQueueStallCount() {
    return seDpVnicRestartOnQueueStallCount;
  }

  public void setSeDpVnicRestartOnQueueStallCount(Integer seDpVnicRestartOnQueueStallCount) {
    this.seDpVnicRestartOnQueueStallCount = seDpVnicRestartOnQueueStallCount;
  }

  public ServiceEngineGroup seDpVnicStallSeRestartWindow(Integer seDpVnicStallSeRestartWindow) {
    this.seDpVnicStallSeRestartWindow = seDpVnicStallSeRestartWindow;
    return this;
  }

   /**
   * Window of time (in seconds) during which se_dp_vnic_restart_on_queue_stall_count number of consecutive stalls results in a SE restart. Field introduced in 18.2.5.
   * @return seDpVnicStallSeRestartWindow
  **/
  @Schema(description = "Window of time (in seconds) during which se_dp_vnic_restart_on_queue_stall_count number of consecutive stalls results in a SE restart. Field introduced in 18.2.5.")
  public Integer getSeDpVnicStallSeRestartWindow() {
    return seDpVnicStallSeRestartWindow;
  }

  public void setSeDpVnicStallSeRestartWindow(Integer seDpVnicStallSeRestartWindow) {
    this.seDpVnicStallSeRestartWindow = seDpVnicStallSeRestartWindow;
  }

  public ServiceEngineGroup seDpdkPmd(Integer seDpdkPmd) {
    this.seDpdkPmd = seDpdkPmd;
    return this;
  }

   /**
   * Determines if DPDK pool mode driver should be used or not   0  Automatically determine based on hypervisor/NIC type 1  Unconditionally use DPDK poll mode driver 2  Don&#x27;t use DPDK poll mode driver.Requires SE Reboot. Allowed values are 0-2. Field introduced in 18.1.3.
   * @return seDpdkPmd
  **/
  @Schema(description = "Determines if DPDK pool mode driver should be used or not   0  Automatically determine based on hypervisor/NIC type 1  Unconditionally use DPDK poll mode driver 2  Don't use DPDK poll mode driver.Requires SE Reboot. Allowed values are 0-2. Field introduced in 18.1.3.")
  public Integer getSeDpdkPmd() {
    return seDpdkPmd;
  }

  public void setSeDpdkPmd(Integer seDpdkPmd) {
    this.seDpdkPmd = seDpdkPmd;
  }

  public ServiceEngineGroup seFlowProbeRetries(Integer seFlowProbeRetries) {
    this.seFlowProbeRetries = seFlowProbeRetries;
    return this;
  }

   /**
   * Flow probe retry count if no replies are received.Requires SE Reboot. Allowed values are 0-5. Field introduced in 18.1.4, 18.2.1.
   * @return seFlowProbeRetries
  **/
  @Schema(description = "Flow probe retry count if no replies are received.Requires SE Reboot. Allowed values are 0-5. Field introduced in 18.1.4, 18.2.1.")
  public Integer getSeFlowProbeRetries() {
    return seFlowProbeRetries;
  }

  public void setSeFlowProbeRetries(Integer seFlowProbeRetries) {
    this.seFlowProbeRetries = seFlowProbeRetries;
  }

  public ServiceEngineGroup seFlowProbeRetryTimer(Integer seFlowProbeRetryTimer) {
    this.seFlowProbeRetryTimer = seFlowProbeRetryTimer;
    return this;
  }

   /**
   * Timeout in milliseconds for flow probe retries.Requires SE Reboot. Allowed values are 20-50. Field introduced in 18.2.5.
   * @return seFlowProbeRetryTimer
  **/
  @Schema(description = "Timeout in milliseconds for flow probe retries.Requires SE Reboot. Allowed values are 20-50. Field introduced in 18.2.5.")
  public Integer getSeFlowProbeRetryTimer() {
    return seFlowProbeRetryTimer;
  }

  public void setSeFlowProbeRetryTimer(Integer seFlowProbeRetryTimer) {
    this.seFlowProbeRetryTimer = seFlowProbeRetryTimer;
  }

  public ServiceEngineGroup seFlowProbeTimer(Integer seFlowProbeTimer) {
    this.seFlowProbeTimer = seFlowProbeTimer;
    return this;
  }

   /**
   * Timeout in milliseconds for flow probe entries. Allowed values are 10-200. Field deprecated in 18.2.5. Field introduced in 18.1.4, 18.2.1.
   * @return seFlowProbeTimer
  **/
  @Schema(description = "Timeout in milliseconds for flow probe entries. Allowed values are 10-200. Field deprecated in 18.2.5. Field introduced in 18.1.4, 18.2.1.")
  public Integer getSeFlowProbeTimer() {
    return seFlowProbeTimer;
  }

  public void setSeFlowProbeTimer(Integer seFlowProbeTimer) {
    this.seFlowProbeTimer = seFlowProbeTimer;
  }

  public ServiceEngineGroup seIpcUdpPort(Integer seIpcUdpPort) {
    this.seIpcUdpPort = seIpcUdpPort;
    return this;
  }

   /**
   * UDP Port for SE_DP IPC in Docker bridge mode. Field deprecated in 20.1.1. Field introduced in 17.1.2.
   * @return seIpcUdpPort
  **/
  @Schema(description = "UDP Port for SE_DP IPC in Docker bridge mode. Field deprecated in 20.1.1. Field introduced in 17.1.2.")
  public Integer getSeIpcUdpPort() {
    return seIpcUdpPort;
  }

  public void setSeIpcUdpPort(Integer seIpcUdpPort) {
    this.seIpcUdpPort = seIpcUdpPort;
  }

  public ServiceEngineGroup seKniBurstFactor(Integer seKniBurstFactor) {
    this.seKniBurstFactor = seKniBurstFactor;
    return this;
  }

   /**
   * Knob to control burst size used in polling KNI interfaces for traffic sent from KNI towards DPDK application Also controls burst size used by KNI module to read pkts punted from DPDK application towards KNI Helps minimize drops in non-VIP traffic in either pathFactor of (0-2) multiplies/divides burst size by 2^N. Allowed values are 0-2. Field introduced in 18.2.6.
   * @return seKniBurstFactor
  **/
  @Schema(description = "Knob to control burst size used in polling KNI interfaces for traffic sent from KNI towards DPDK application Also controls burst size used by KNI module to read pkts punted from DPDK application towards KNI Helps minimize drops in non-VIP traffic in either pathFactor of (0-2) multiplies/divides burst size by 2^N. Allowed values are 0-2. Field introduced in 18.2.6.")
  public Integer getSeKniBurstFactor() {
    return seKniBurstFactor;
  }

  public void setSeKniBurstFactor(Integer seKniBurstFactor) {
    this.seKniBurstFactor = seKniBurstFactor;
  }

  public ServiceEngineGroup seLro(Boolean seLro) {
    this.seLro = seLro;
    return this;
  }

   /**
   * Enable or disable Large Receive Optimization for vnics. Requires SE Reboot. Field introduced in 18.2.5.
   * @return seLro
  **/
  @Schema(description = "Enable or disable Large Receive Optimization for vnics. Requires SE Reboot. Field introduced in 18.2.5.")
  public Boolean isSeLro() {
    return seLro;
  }

  public void setSeLro(Boolean seLro) {
    this.seLro = seLro;
  }

  public ServiceEngineGroup seMtu(Integer seMtu) {
    this.seMtu = seMtu;
    return this;
  }

   /**
   * MTU for the VNICs of SEs in the SE group. Allowed values are 512-9000. Field introduced in 18.2.8, 20.1.1.
   * @return seMtu
  **/
  @Schema(description = "MTU for the VNICs of SEs in the SE group. Allowed values are 512-9000. Field introduced in 18.2.8, 20.1.1.")
  public Integer getSeMtu() {
    return seMtu;
  }

  public void setSeMtu(Integer seMtu) {
    this.seMtu = seMtu;
  }

  public ServiceEngineGroup seNamePrefix(String seNamePrefix) {
    this.seNamePrefix = seNamePrefix;
    return this;
  }

   /**
   * Prefix to use for virtual machine name of Service Engines.
   * @return seNamePrefix
  **/
  @Schema(description = "Prefix to use for virtual machine name of Service Engines.")
  public String getSeNamePrefix() {
    return seNamePrefix;
  }

  public void setSeNamePrefix(String seNamePrefix) {
    this.seNamePrefix = seNamePrefix;
  }

  public ServiceEngineGroup sePcapLookahead(Boolean sePcapLookahead) {
    this.sePcapLookahead = sePcapLookahead;
    return this;
  }

   /**
   * Enables lookahead mode of packet receive in PCAP mode. Introduced to overcome an issue with hv_netvsc driver. Lookahead mode attempts to ensure that application and kernel&#x27;s view of the receive rings are consistent. Field introduced in 18.2.3.
   * @return sePcapLookahead
  **/
  @Schema(description = "Enables lookahead mode of packet receive in PCAP mode. Introduced to overcome an issue with hv_netvsc driver. Lookahead mode attempts to ensure that application and kernel's view of the receive rings are consistent. Field introduced in 18.2.3.")
  public Boolean isSePcapLookahead() {
    return sePcapLookahead;
  }

  public void setSePcapLookahead(Boolean sePcapLookahead) {
    this.sePcapLookahead = sePcapLookahead;
  }

  public ServiceEngineGroup sePcapPktCount(Integer sePcapPktCount) {
    this.sePcapPktCount = sePcapPktCount;
    return this;
  }

   /**
   * Max number of packets the pcap interface can hold and if the value is 0 the optimum value will be chosen. The optimum value will be chosen based on SE-memory, Cloud Type and Number of Interfaces.Requires SE Reboot. Field introduced in 18.2.5.
   * @return sePcapPktCount
  **/
  @Schema(description = "Max number of packets the pcap interface can hold and if the value is 0 the optimum value will be chosen. The optimum value will be chosen based on SE-memory, Cloud Type and Number of Interfaces.Requires SE Reboot. Field introduced in 18.2.5.")
  public Integer getSePcapPktCount() {
    return sePcapPktCount;
  }

  public void setSePcapPktCount(Integer sePcapPktCount) {
    this.sePcapPktCount = sePcapPktCount;
  }

  public ServiceEngineGroup sePcapPktSz(Integer sePcapPktSz) {
    this.sePcapPktSz = sePcapPktSz;
    return this;
  }

   /**
   * Max size of each packet in the pcap interface. Requires SE Reboot. Field introduced in 18.2.5.
   * @return sePcapPktSz
  **/
  @Schema(description = "Max size of each packet in the pcap interface. Requires SE Reboot. Field introduced in 18.2.5.")
  public Integer getSePcapPktSz() {
    return sePcapPktSz;
  }

  public void setSePcapPktSz(Integer sePcapPktSz) {
    this.sePcapPktSz = sePcapPktSz;
  }

  public ServiceEngineGroup sePcapQdiscBypass(Boolean sePcapQdiscBypass) {
    this.sePcapQdiscBypass = sePcapQdiscBypass;
    return this;
  }

   /**
   * Bypass the kernel&#x27;s traffic control layer, to deliver packets directly to the driver. Enabling this feature results in egress packets not being captured in host tcpdump. Note   brief packet reordering or loss may occur upon toggle. Field introduced in 18.2.6.
   * @return sePcapQdiscBypass
  **/
  @Schema(description = "Bypass the kernel's traffic control layer, to deliver packets directly to the driver. Enabling this feature results in egress packets not being captured in host tcpdump. Note   brief packet reordering or loss may occur upon toggle. Field introduced in 18.2.6.")
  public Boolean isSePcapQdiscBypass() {
    return sePcapQdiscBypass;
  }

  public void setSePcapQdiscBypass(Boolean sePcapQdiscBypass) {
    this.sePcapQdiscBypass = sePcapQdiscBypass;
  }

  public ServiceEngineGroup sePcapReinitFrequency(Integer sePcapReinitFrequency) {
    this.sePcapReinitFrequency = sePcapReinitFrequency;
    return this;
  }

   /**
   * Frequency in seconds at which periodically a PCAP reinit check is triggered. May be used in conjunction with the configuration pcap_reinit_threshold. (Valid range   15 mins - 12 hours, 0 - disables). Allowed values are 900-43200. Special values are 0- &#x27;disable&#x27;. Field introduced in 17.2.13, 18.1.3, 18.2.1.
   * @return sePcapReinitFrequency
  **/
  @Schema(description = "Frequency in seconds at which periodically a PCAP reinit check is triggered. May be used in conjunction with the configuration pcap_reinit_threshold. (Valid range   15 mins - 12 hours, 0 - disables). Allowed values are 900-43200. Special values are 0- 'disable'. Field introduced in 17.2.13, 18.1.3, 18.2.1.")
  public Integer getSePcapReinitFrequency() {
    return sePcapReinitFrequency;
  }

  public void setSePcapReinitFrequency(Integer sePcapReinitFrequency) {
    this.sePcapReinitFrequency = sePcapReinitFrequency;
  }

  public ServiceEngineGroup sePcapReinitThreshold(Integer sePcapReinitThreshold) {
    this.sePcapReinitThreshold = sePcapReinitThreshold;
    return this;
  }

   /**
   * Threshold for input packet receive errors in PCAP mode exceeding which a PCAP reinit is triggered. If not set, an unconditional reinit is performed. This value is checked every pcap_reinit_frequency interval. Field introduced in 17.2.13, 18.1.3, 18.2.1.
   * @return sePcapReinitThreshold
  **/
  @Schema(description = "Threshold for input packet receive errors in PCAP mode exceeding which a PCAP reinit is triggered. If not set, an unconditional reinit is performed. This value is checked every pcap_reinit_frequency interval. Field introduced in 17.2.13, 18.1.3, 18.2.1.")
  public Integer getSePcapReinitThreshold() {
    return sePcapReinitThreshold;
  }

  public void setSePcapReinitThreshold(Integer sePcapReinitThreshold) {
    this.sePcapReinitThreshold = sePcapReinitThreshold;
  }

  public ServiceEngineGroup seProbePort(Integer seProbePort) {
    this.seProbePort = seProbePort;
    return this;
  }

   /**
   * TCP port on SE where echo service will be run. Field introduced in 17.2.2.
   * @return seProbePort
  **/
  @Schema(description = "TCP port on SE where echo service will be run. Field introduced in 17.2.2.")
  public Integer getSeProbePort() {
    return seProbePort;
  }

  public void setSeProbePort(Integer seProbePort) {
    this.seProbePort = seProbePort;
  }

  public ServiceEngineGroup seRemotePuntUdpPort(Integer seRemotePuntUdpPort) {
    this.seRemotePuntUdpPort = seRemotePuntUdpPort;
    return this;
  }

   /**
   * UDP Port for punted packets in Docker bridge mode. Field deprecated in 20.1.1. Field introduced in 17.1.2.
   * @return seRemotePuntUdpPort
  **/
  @Schema(description = "UDP Port for punted packets in Docker bridge mode. Field deprecated in 20.1.1. Field introduced in 17.1.2.")
  public Integer getSeRemotePuntUdpPort() {
    return seRemotePuntUdpPort;
  }

  public void setSeRemotePuntUdpPort(Integer seRemotePuntUdpPort) {
    this.seRemotePuntUdpPort = seRemotePuntUdpPort;
  }

  public ServiceEngineGroup seRlProp(RateLimiterProperties seRlProp) {
    this.seRlProp = seRlProp;
    return this;
  }

   /**
   * Get seRlProp
   * @return seRlProp
  **/
  @Schema(description = "")
  public RateLimiterProperties getSeRlProp() {
    return seRlProp;
  }

  public void setSeRlProp(RateLimiterProperties seRlProp) {
    this.seRlProp = seRlProp;
  }

  public ServiceEngineGroup seRouting(Boolean seRouting) {
    this.seRouting = seRouting;
    return this;
  }

   /**
   * Enable routing via Service Engine Datapath. When disabled, routing is done by the Linux kernel. IP Routing needs to be enabled in Service Engine Group for SE Routing to be effective. Field deprecated in 18.2.5. Field introduced in 18.2.3.
   * @return seRouting
  **/
  @Schema(description = "Enable routing via Service Engine Datapath. When disabled, routing is done by the Linux kernel. IP Routing needs to be enabled in Service Engine Group for SE Routing to be effective. Field deprecated in 18.2.5. Field introduced in 18.2.3.")
  public Boolean isSeRouting() {
    return seRouting;
  }

  public void setSeRouting(Boolean seRouting) {
    this.seRouting = seRouting;
  }

  public ServiceEngineGroup seRumSamplingNavInterval(Integer seRumSamplingNavInterval) {
    this.seRumSamplingNavInterval = seRumSamplingNavInterval;
    return this;
  }

   /**
   * Minimum time to wait on server between taking sampleswhen sampling the navigation timing data from the end user client. Field introduced in 18.2.6.
   * @return seRumSamplingNavInterval
  **/
  @Schema(description = "Minimum time to wait on server between taking sampleswhen sampling the navigation timing data from the end user client. Field introduced in 18.2.6.")
  public Integer getSeRumSamplingNavInterval() {
    return seRumSamplingNavInterval;
  }

  public void setSeRumSamplingNavInterval(Integer seRumSamplingNavInterval) {
    this.seRumSamplingNavInterval = seRumSamplingNavInterval;
  }

  public ServiceEngineGroup seRumSamplingNavPercent(Integer seRumSamplingNavPercent) {
    this.seRumSamplingNavPercent = seRumSamplingNavPercent;
    return this;
  }

   /**
   * Percentage of navigation timing data from the end user client, used for sampling to get client insights. Field introduced in 18.2.6.
   * @return seRumSamplingNavPercent
  **/
  @Schema(description = "Percentage of navigation timing data from the end user client, used for sampling to get client insights. Field introduced in 18.2.6.")
  public Integer getSeRumSamplingNavPercent() {
    return seRumSamplingNavPercent;
  }

  public void setSeRumSamplingNavPercent(Integer seRumSamplingNavPercent) {
    this.seRumSamplingNavPercent = seRumSamplingNavPercent;
  }

  public ServiceEngineGroup seRumSamplingResInterval(Integer seRumSamplingResInterval) {
    this.seRumSamplingResInterval = seRumSamplingResInterval;
    return this;
  }

   /**
   * Minimum time to wait on server between taking sampleswhen sampling the resource timing data from the end user client. Field introduced in 18.2.6.
   * @return seRumSamplingResInterval
  **/
  @Schema(description = "Minimum time to wait on server between taking sampleswhen sampling the resource timing data from the end user client. Field introduced in 18.2.6.")
  public Integer getSeRumSamplingResInterval() {
    return seRumSamplingResInterval;
  }

  public void setSeRumSamplingResInterval(Integer seRumSamplingResInterval) {
    this.seRumSamplingResInterval = seRumSamplingResInterval;
  }

  public ServiceEngineGroup seRumSamplingResPercent(Integer seRumSamplingResPercent) {
    this.seRumSamplingResPercent = seRumSamplingResPercent;
    return this;
  }

   /**
   * Percentage of resource timing data from the end user client used for sampling to get client insight. Field introduced in 18.2.6.
   * @return seRumSamplingResPercent
  **/
  @Schema(description = "Percentage of resource timing data from the end user client used for sampling to get client insight. Field introduced in 18.2.6.")
  public Integer getSeRumSamplingResPercent() {
    return seRumSamplingResPercent;
  }

  public void setSeRumSamplingResPercent(Integer seRumSamplingResPercent) {
    this.seRumSamplingResPercent = seRumSamplingResPercent;
  }

  public ServiceEngineGroup seSbDedicatedCore(Boolean seSbDedicatedCore) {
    this.seSbDedicatedCore = seSbDedicatedCore;
    return this;
  }

   /**
   * Sideband traffic will be handled by a dedicated core.Requires SE Reboot. Field introduced in 16.5.2, 17.1.9, 17.2.3.
   * @return seSbDedicatedCore
  **/
  @Schema(description = "Sideband traffic will be handled by a dedicated core.Requires SE Reboot. Field introduced in 16.5.2, 17.1.9, 17.2.3.")
  public Boolean isSeSbDedicatedCore() {
    return seSbDedicatedCore;
  }

  public void setSeSbDedicatedCore(Boolean seSbDedicatedCore) {
    this.seSbDedicatedCore = seSbDedicatedCore;
  }

  public ServiceEngineGroup seSbThreads(Integer seSbThreads) {
    this.seSbThreads = seSbThreads;
    return this;
  }

   /**
   * Number of Sideband threads per SE.Requires SE Reboot. Allowed values are 1-128. Field introduced in 16.5.2, 17.1.9, 17.2.3.
   * @return seSbThreads
  **/
  @Schema(description = "Number of Sideband threads per SE.Requires SE Reboot. Allowed values are 1-128. Field introduced in 16.5.2, 17.1.9, 17.2.3.")
  public Integer getSeSbThreads() {
    return seSbThreads;
  }

  public void setSeSbThreads(Integer seSbThreads) {
    this.seSbThreads = seSbThreads;
  }

  public ServiceEngineGroup seThreadMultiplier(Integer seThreadMultiplier) {
    this.seThreadMultiplier = seThreadMultiplier;
    return this;
  }

   /**
   * Multiplier for SE threads based on vCPU. Allowed values are 1-10.
   * @return seThreadMultiplier
  **/
  @Schema(description = "Multiplier for SE threads based on vCPU. Allowed values are 1-10.")
  public Integer getSeThreadMultiplier() {
    return seThreadMultiplier;
  }

  public void setSeThreadMultiplier(Integer seThreadMultiplier) {
    this.seThreadMultiplier = seThreadMultiplier;
  }

  public ServiceEngineGroup seTracertPortRange(PortRange seTracertPortRange) {
    this.seTracertPortRange = seTracertPortRange;
    return this;
  }

   /**
   * Get seTracertPortRange
   * @return seTracertPortRange
  **/
  @Schema(description = "")
  public PortRange getSeTracertPortRange() {
    return seTracertPortRange;
  }

  public void setSeTracertPortRange(PortRange seTracertPortRange) {
    this.seTracertPortRange = seTracertPortRange;
  }

  public ServiceEngineGroup seTunnelMode(Integer seTunnelMode) {
    this.seTunnelMode = seTunnelMode;
    return this;
  }

   /**
   * Determines if DSR from secondary SE is active or not  0  Automatically determine based on hypervisor type. 1  Disable DSR unconditionally. 2  Enable DSR unconditionally. Allowed values are 0-2. Field introduced in 17.1.1.
   * @return seTunnelMode
  **/
  @Schema(description = "Determines if DSR from secondary SE is active or not  0  Automatically determine based on hypervisor type. 1  Disable DSR unconditionally. 2  Enable DSR unconditionally. Allowed values are 0-2. Field introduced in 17.1.1.")
  public Integer getSeTunnelMode() {
    return seTunnelMode;
  }

  public void setSeTunnelMode(Integer seTunnelMode) {
    this.seTunnelMode = seTunnelMode;
  }

  public ServiceEngineGroup seTunnelUdpPort(Integer seTunnelUdpPort) {
    this.seTunnelUdpPort = seTunnelUdpPort;
    return this;
  }

   /**
   * UDP Port for tunneled packets from secondary to primary SE in Docker bridge mode.Requires SE Reboot. Field introduced in 17.1.3.
   * @return seTunnelUdpPort
  **/
  @Schema(description = "UDP Port for tunneled packets from secondary to primary SE in Docker bridge mode.Requires SE Reboot. Field introduced in 17.1.3.")
  public Integer getSeTunnelUdpPort() {
    return seTunnelUdpPort;
  }

  public void setSeTunnelUdpPort(Integer seTunnelUdpPort) {
    this.seTunnelUdpPort = seTunnelUdpPort;
  }

  public ServiceEngineGroup seTxBatchSize(Integer seTxBatchSize) {
    this.seTxBatchSize = seTxBatchSize;
    return this;
  }

   /**
   * Number of packets to batch for transmit to the nic. Requires SE Reboot. Field introduced in 18.2.5.
   * @return seTxBatchSize
  **/
  @Schema(description = "Number of packets to batch for transmit to the nic. Requires SE Reboot. Field introduced in 18.2.5.")
  public Integer getSeTxBatchSize() {
    return seTxBatchSize;
  }

  public void setSeTxBatchSize(Integer seTxBatchSize) {
    this.seTxBatchSize = seTxBatchSize;
  }

  public ServiceEngineGroup seUdpEncapIpc(Integer seUdpEncapIpc) {
    this.seUdpEncapIpc = seUdpEncapIpc;
    return this;
  }

   /**
   * Determines if SE-SE IPC messages are encapsulated in a UDP header  0  Automatically determine based on hypervisor type. 1  Use UDP encap unconditionally.Requires SE Reboot. Allowed values are 0-1. Field introduced in 17.1.2.
   * @return seUdpEncapIpc
  **/
  @Schema(description = "Determines if SE-SE IPC messages are encapsulated in a UDP header  0  Automatically determine based on hypervisor type. 1  Use UDP encap unconditionally.Requires SE Reboot. Allowed values are 0-1. Field introduced in 17.1.2.")
  public Integer getSeUdpEncapIpc() {
    return seUdpEncapIpc;
  }

  public void setSeUdpEncapIpc(Integer seUdpEncapIpc) {
    this.seUdpEncapIpc = seUdpEncapIpc;
  }

  public ServiceEngineGroup seUseDpdk(Integer seUseDpdk) {
    this.seUseDpdk = seUseDpdk;
    return this;
  }

   /**
   * Determines if DPDK library should be used or not   0  Automatically determine based on hypervisor type 1  Use DPDK if PCAP is not enabled 2  Don&#x27;t use DPDK. Allowed values are 0-2. Field introduced in 18.1.3.
   * @return seUseDpdk
  **/
  @Schema(description = "Determines if DPDK library should be used or not   0  Automatically determine based on hypervisor type 1  Use DPDK if PCAP is not enabled 2  Don't use DPDK. Allowed values are 0-2. Field introduced in 18.1.3.")
  public Integer getSeUseDpdk() {
    return seUseDpdk;
  }

  public void setSeUseDpdk(Integer seUseDpdk) {
    this.seUseDpdk = seUseDpdk;
  }

  public ServiceEngineGroup seVsHbMaxPktsInBatch(Integer seVsHbMaxPktsInBatch) {
    this.seVsHbMaxPktsInBatch = seVsHbMaxPktsInBatch;
    return this;
  }

   /**
   * Maximum number of aggregated vs heartbeat packets to send in a batch. Allowed values are 1-256. Field introduced in 17.1.1.
   * @return seVsHbMaxPktsInBatch
  **/
  @Schema(description = "Maximum number of aggregated vs heartbeat packets to send in a batch. Allowed values are 1-256. Field introduced in 17.1.1.")
  public Integer getSeVsHbMaxPktsInBatch() {
    return seVsHbMaxPktsInBatch;
  }

  public void setSeVsHbMaxPktsInBatch(Integer seVsHbMaxPktsInBatch) {
    this.seVsHbMaxPktsInBatch = seVsHbMaxPktsInBatch;
  }

  public ServiceEngineGroup seVsHbMaxVsInPkt(Integer seVsHbMaxVsInPkt) {
    this.seVsHbMaxVsInPkt = seVsHbMaxVsInPkt;
    return this;
  }

   /**
   * Maximum number of virtualservices for which heartbeat messages are aggregated in one packet. Allowed values are 1-1024. Field introduced in 17.1.1.
   * @return seVsHbMaxVsInPkt
  **/
  @Schema(description = "Maximum number of virtualservices for which heartbeat messages are aggregated in one packet. Allowed values are 1-1024. Field introduced in 17.1.1.")
  public Integer getSeVsHbMaxVsInPkt() {
    return seVsHbMaxVsInPkt;
  }

  public void setSeVsHbMaxVsInPkt(Integer seVsHbMaxVsInPkt) {
    this.seVsHbMaxVsInPkt = seVsHbMaxVsInPkt;
  }

  public ServiceEngineGroup selfSeElection(Boolean selfSeElection) {
    this.selfSeElection = selfSeElection;
    return this;
  }

   /**
   * Enable SEs to elect a primary amongst themselves in the absence of a connectivity to controller. Field introduced in 18.1.2.
   * @return selfSeElection
  **/
  @Schema(description = "Enable SEs to elect a primary amongst themselves in the absence of a connectivity to controller. Field introduced in 18.1.2.")
  public Boolean isSelfSeElection() {
    return selfSeElection;
  }

  public void setSelfSeElection(Boolean selfSeElection) {
    this.selfSeElection = selfSeElection;
  }

  public ServiceEngineGroup serviceIp6Subnets(List<IpAddrPrefix> serviceIp6Subnets) {
    this.serviceIp6Subnets = serviceIp6Subnets;
    return this;
  }

  public ServiceEngineGroup addServiceIp6SubnetsItem(IpAddrPrefix serviceIp6SubnetsItem) {
    if (this.serviceIp6Subnets == null) {
      this.serviceIp6Subnets = new ArrayList<IpAddrPrefix>();
    }
    this.serviceIp6Subnets.add(serviceIp6SubnetsItem);
    return this;
  }

   /**
   * IPv6 Subnets assigned to the SE group. Required for VS group placement. Field introduced in 18.1.1.
   * @return serviceIp6Subnets
  **/
  @Schema(description = "IPv6 Subnets assigned to the SE group. Required for VS group placement. Field introduced in 18.1.1.")
  public List<IpAddrPrefix> getServiceIp6Subnets() {
    return serviceIp6Subnets;
  }

  public void setServiceIp6Subnets(List<IpAddrPrefix> serviceIp6Subnets) {
    this.serviceIp6Subnets = serviceIp6Subnets;
  }

  public ServiceEngineGroup serviceIpSubnets(List<IpAddrPrefix> serviceIpSubnets) {
    this.serviceIpSubnets = serviceIpSubnets;
    return this;
  }

  public ServiceEngineGroup addServiceIpSubnetsItem(IpAddrPrefix serviceIpSubnetsItem) {
    if (this.serviceIpSubnets == null) {
      this.serviceIpSubnets = new ArrayList<IpAddrPrefix>();
    }
    this.serviceIpSubnets.add(serviceIpSubnetsItem);
    return this;
  }

   /**
   * Subnets assigned to the SE group. Required for VS group placement. Field introduced in 17.1.1.
   * @return serviceIpSubnets
  **/
  @Schema(description = "Subnets assigned to the SE group. Required for VS group placement. Field introduced in 17.1.1.")
  public List<IpAddrPrefix> getServiceIpSubnets() {
    return serviceIpSubnets;
  }

  public void setServiceIpSubnets(List<IpAddrPrefix> serviceIpSubnets) {
    this.serviceIpSubnets = serviceIpSubnets;
  }

  public ServiceEngineGroup shmMinimumConfigMemory(Integer shmMinimumConfigMemory) {
    this.shmMinimumConfigMemory = shmMinimumConfigMemory;
    return this;
  }

   /**
   * Minimum required shared memory to apply any configuration. Allowed values are 0-100. Field introduced in 18.1.2.
   * @return shmMinimumConfigMemory
  **/
  @Schema(description = "Minimum required shared memory to apply any configuration. Allowed values are 0-100. Field introduced in 18.1.2.")
  public Integer getShmMinimumConfigMemory() {
    return shmMinimumConfigMemory;
  }

  public void setShmMinimumConfigMemory(Integer shmMinimumConfigMemory) {
    this.shmMinimumConfigMemory = shmMinimumConfigMemory;
  }

  public ServiceEngineGroup significantLogThrottle(Integer significantLogThrottle) {
    this.significantLogThrottle = significantLogThrottle;
    return this;
  }

   /**
   * This setting limits the number of significant logs generated per second per core on this SE. Default is 100 logs per second. Set it to zero (0) to disable throttling. Field introduced in 17.1.3.
   * @return significantLogThrottle
  **/
  @Schema(description = "This setting limits the number of significant logs generated per second per core on this SE. Default is 100 logs per second. Set it to zero (0) to disable throttling. Field introduced in 17.1.3.")
  public Integer getSignificantLogThrottle() {
    return significantLogThrottle;
  }

  public void setSignificantLogThrottle(Integer significantLogThrottle) {
    this.significantLogThrottle = significantLogThrottle;
  }

  public ServiceEngineGroup sslPreprocessSniHostname(Boolean sslPreprocessSniHostname) {
    this.sslPreprocessSniHostname = sslPreprocessSniHostname;
    return this;
  }

   /**
   * (Beta) Preprocess SSL Client Hello for SNI hostname extension.If set to True, this will apply SNI child&#x27;s SSL protocol(s), if they are different from SNI Parent&#x27;s allowed SSL protocol(s). Field introduced in 17.2.12, 18.1.3.
   * @return sslPreprocessSniHostname
  **/
  @Schema(description = "(Beta) Preprocess SSL Client Hello for SNI hostname extension.If set to True, this will apply SNI child's SSL protocol(s), if they are different from SNI Parent's allowed SSL protocol(s). Field introduced in 17.2.12, 18.1.3.")
  public Boolean isSslPreprocessSniHostname() {
    return sslPreprocessSniHostname;
  }

  public void setSslPreprocessSniHostname(Boolean sslPreprocessSniHostname) {
    this.sslPreprocessSniHostname = sslPreprocessSniHostname;
  }

  public ServiceEngineGroup tenantRef(String tenantRef) {
    this.tenantRef = tenantRef;
    return this;
  }

   /**
   *  It is a reference to an object of type Tenant.
   * @return tenantRef
  **/
  @Schema(description = " It is a reference to an object of type Tenant.")
  public String getTenantRef() {
    return tenantRef;
  }

  public void setTenantRef(String tenantRef) {
    this.tenantRef = tenantRef;
  }

  public ServiceEngineGroup udfLogThrottle(Integer udfLogThrottle) {
    this.udfLogThrottle = udfLogThrottle;
    return this;
  }

   /**
   * This setting limits the number of UDF logs generated per second per core on this SE. UDF logs are generated due to the configured client log filters or the rules with logging enabled. Default is 100 logs per second. Set it to zero (0) to disable throttling. Field introduced in 17.1.3.
   * @return udfLogThrottle
  **/
  @Schema(description = "This setting limits the number of UDF logs generated per second per core on this SE. UDF logs are generated due to the configured client log filters or the rules with logging enabled. Default is 100 logs per second. Set it to zero (0) to disable throttling. Field introduced in 17.1.3.")
  public Integer getUdfLogThrottle() {
    return udfLogThrottle;
  }

  public void setUdfLogThrottle(Integer udfLogThrottle) {
    this.udfLogThrottle = udfLogThrottle;
  }

   /**
   * url
   * @return url
  **/
  @Schema(description = "url")
  public String getUrl() {
    return url;
  }

  public ServiceEngineGroup useStandardAlb(Boolean useStandardAlb) {
    this.useStandardAlb = useStandardAlb;
    return this;
  }

   /**
   * Use Standard SKU Azure Load Balancer. By default cloud level flag is set. If not set, it inherits/uses the use_standard_alb flag from the cloud. Field introduced in 18.2.3.
   * @return useStandardAlb
  **/
  @Schema(description = "Use Standard SKU Azure Load Balancer. By default cloud level flag is set. If not set, it inherits/uses the use_standard_alb flag from the cloud. Field introduced in 18.2.3.")
  public Boolean isUseStandardAlb() {
    return useStandardAlb;
  }

  public void setUseStandardAlb(Boolean useStandardAlb) {
    this.useStandardAlb = useStandardAlb;
  }

  public ServiceEngineGroup uuid(String uuid) {
    this.uuid = uuid;
    return this;
  }

   /**
   * Unique object identifier of the object.
   * @return uuid
  **/
  @Schema(description = "Unique object identifier of the object.")
  public String getUuid() {
    return uuid;
  }

  public void setUuid(String uuid) {
    this.uuid = uuid;
  }

  public ServiceEngineGroup vcenterClusters(VcenterClusters vcenterClusters) {
    this.vcenterClusters = vcenterClusters;
    return this;
  }

   /**
   * Get vcenterClusters
   * @return vcenterClusters
  **/
  @Schema(description = "")
  public VcenterClusters getVcenterClusters() {
    return vcenterClusters;
  }

  public void setVcenterClusters(VcenterClusters vcenterClusters) {
    this.vcenterClusters = vcenterClusters;
  }

  public ServiceEngineGroup vcenterDatastoreMode(String vcenterDatastoreMode) {
    this.vcenterDatastoreMode = vcenterDatastoreMode;
    return this;
  }

   /**
   *  Enum options - VCENTER_DATASTORE_ANY, VCENTER_DATASTORE_LOCAL, VCENTER_DATASTORE_SHARED.
   * @return vcenterDatastoreMode
  **/
  @Schema(description = " Enum options - VCENTER_DATASTORE_ANY, VCENTER_DATASTORE_LOCAL, VCENTER_DATASTORE_SHARED.")
  public String getVcenterDatastoreMode() {
    return vcenterDatastoreMode;
  }

  public void setVcenterDatastoreMode(String vcenterDatastoreMode) {
    this.vcenterDatastoreMode = vcenterDatastoreMode;
  }

  public ServiceEngineGroup vcenterDatastores(List<VcenterDatastore> vcenterDatastores) {
    this.vcenterDatastores = vcenterDatastores;
    return this;
  }

  public ServiceEngineGroup addVcenterDatastoresItem(VcenterDatastore vcenterDatastoresItem) {
    if (this.vcenterDatastores == null) {
      this.vcenterDatastores = new ArrayList<VcenterDatastore>();
    }
    this.vcenterDatastores.add(vcenterDatastoresItem);
    return this;
  }

   /**
   * Placeholder for description of property vcenter_datastores of obj type ServiceEngineGroup field type str  type object
   * @return vcenterDatastores
  **/
  @Schema(description = "Placeholder for description of property vcenter_datastores of obj type ServiceEngineGroup field type str  type object")
  public List<VcenterDatastore> getVcenterDatastores() {
    return vcenterDatastores;
  }

  public void setVcenterDatastores(List<VcenterDatastore> vcenterDatastores) {
    this.vcenterDatastores = vcenterDatastores;
  }

  public ServiceEngineGroup vcenterDatastoresInclude(Boolean vcenterDatastoresInclude) {
    this.vcenterDatastoresInclude = vcenterDatastoresInclude;
    return this;
  }

   /**
   * Placeholder for description of property vcenter_datastores_include of obj type ServiceEngineGroup field type str  type boolean
   * @return vcenterDatastoresInclude
  **/
  @Schema(description = "Placeholder for description of property vcenter_datastores_include of obj type ServiceEngineGroup field type str  type boolean")
  public Boolean isVcenterDatastoresInclude() {
    return vcenterDatastoresInclude;
  }

  public void setVcenterDatastoresInclude(Boolean vcenterDatastoresInclude) {
    this.vcenterDatastoresInclude = vcenterDatastoresInclude;
  }

  public ServiceEngineGroup vcenterFolder(String vcenterFolder) {
    this.vcenterFolder = vcenterFolder;
    return this;
  }

   /**
   * Folder to place all the Service Engine virtual machines in vCenter.
   * @return vcenterFolder
  **/
  @Schema(description = "Folder to place all the Service Engine virtual machines in vCenter.")
  public String getVcenterFolder() {
    return vcenterFolder;
  }

  public void setVcenterFolder(String vcenterFolder) {
    this.vcenterFolder = vcenterFolder;
  }

  public ServiceEngineGroup vcenterHosts(VcenterHosts vcenterHosts) {
    this.vcenterHosts = vcenterHosts;
    return this;
  }

   /**
   * Get vcenterHosts
   * @return vcenterHosts
  **/
  @Schema(description = "")
  public VcenterHosts getVcenterHosts() {
    return vcenterHosts;
  }

  public void setVcenterHosts(VcenterHosts vcenterHosts) {
    this.vcenterHosts = vcenterHosts;
  }

  public ServiceEngineGroup vcpusPerSe(Integer vcpusPerSe) {
    this.vcpusPerSe = vcpusPerSe;
    return this;
  }

   /**
   * Number of vcpus for each of the Service Engine virtual machines.
   * @return vcpusPerSe
  **/
  @Schema(description = "Number of vcpus for each of the Service Engine virtual machines.")
  public Integer getVcpusPerSe() {
    return vcpusPerSe;
  }

  public void setVcpusPerSe(Integer vcpusPerSe) {
    this.vcpusPerSe = vcpusPerSe;
  }

  public ServiceEngineGroup vipAsg(VipAutoscaleGroup vipAsg) {
    this.vipAsg = vipAsg;
    return this;
  }

   /**
   * Get vipAsg
   * @return vipAsg
  **/
  @Schema(description = "")
  public VipAutoscaleGroup getVipAsg() {
    return vipAsg;
  }

  public void setVipAsg(VipAutoscaleGroup vipAsg) {
    this.vipAsg = vipAsg;
  }

  public ServiceEngineGroup vsHostRedundancy(Boolean vsHostRedundancy) {
    this.vsHostRedundancy = vsHostRedundancy;
    return this;
  }

   /**
   * Ensure primary and secondary Service Engines are deployed on different physical hosts.
   * @return vsHostRedundancy
  **/
  @Schema(description = "Ensure primary and secondary Service Engines are deployed on different physical hosts.")
  public Boolean isVsHostRedundancy() {
    return vsHostRedundancy;
  }

  public void setVsHostRedundancy(Boolean vsHostRedundancy) {
    this.vsHostRedundancy = vsHostRedundancy;
  }

  public ServiceEngineGroup vsScaleinTimeout(Integer vsScaleinTimeout) {
    this.vsScaleinTimeout = vsScaleinTimeout;
    return this;
  }

   /**
   * Time to wait for the scaled in SE to drain existing flows before marking the scalein done.
   * @return vsScaleinTimeout
  **/
  @Schema(description = "Time to wait for the scaled in SE to drain existing flows before marking the scalein done.")
  public Integer getVsScaleinTimeout() {
    return vsScaleinTimeout;
  }

  public void setVsScaleinTimeout(Integer vsScaleinTimeout) {
    this.vsScaleinTimeout = vsScaleinTimeout;
  }

  public ServiceEngineGroup vsScaleinTimeoutForUpgrade(Integer vsScaleinTimeoutForUpgrade) {
    this.vsScaleinTimeoutForUpgrade = vsScaleinTimeoutForUpgrade;
    return this;
  }

   /**
   * During SE upgrade, Time to wait for the scaled-in SE to drain existing flows before marking the scalein done.
   * @return vsScaleinTimeoutForUpgrade
  **/
  @Schema(description = "During SE upgrade, Time to wait for the scaled-in SE to drain existing flows before marking the scalein done.")
  public Integer getVsScaleinTimeoutForUpgrade() {
    return vsScaleinTimeoutForUpgrade;
  }

  public void setVsScaleinTimeoutForUpgrade(Integer vsScaleinTimeoutForUpgrade) {
    this.vsScaleinTimeoutForUpgrade = vsScaleinTimeoutForUpgrade;
  }

  public ServiceEngineGroup vsScaleoutTimeout(Integer vsScaleoutTimeout) {
    this.vsScaleoutTimeout = vsScaleoutTimeout;
    return this;
  }

   /**
   * Time to wait for the scaled out SE to become ready before marking the scaleout done.
   * @return vsScaleoutTimeout
  **/
  @Schema(description = "Time to wait for the scaled out SE to become ready before marking the scaleout done.")
  public Integer getVsScaleoutTimeout() {
    return vsScaleoutTimeout;
  }

  public void setVsScaleoutTimeout(Integer vsScaleoutTimeout) {
    this.vsScaleoutTimeout = vsScaleoutTimeout;
  }

  public ServiceEngineGroup vsSeScaleoutAdditionalWaitTime(Integer vsSeScaleoutAdditionalWaitTime) {
    this.vsSeScaleoutAdditionalWaitTime = vsSeScaleoutAdditionalWaitTime;
    return this;
  }

   /**
   * Wait time for sending scaleout ready notification after Virtual Service is marked UP. In certain deployments, there may be an additional delay to accept traffic. For example, for BGP, some time is needed for route advertisement. Allowed values are 0-20. Field introduced in 18.1.5,18.2.1.
   * @return vsSeScaleoutAdditionalWaitTime
  **/
  @Schema(description = "Wait time for sending scaleout ready notification after Virtual Service is marked UP. In certain deployments, there may be an additional delay to accept traffic. For example, for BGP, some time is needed for route advertisement. Allowed values are 0-20. Field introduced in 18.1.5,18.2.1.")
  public Integer getVsSeScaleoutAdditionalWaitTime() {
    return vsSeScaleoutAdditionalWaitTime;
  }

  public void setVsSeScaleoutAdditionalWaitTime(Integer vsSeScaleoutAdditionalWaitTime) {
    this.vsSeScaleoutAdditionalWaitTime = vsSeScaleoutAdditionalWaitTime;
  }

  public ServiceEngineGroup vsSeScaleoutReadyTimeout(Integer vsSeScaleoutReadyTimeout) {
    this.vsSeScaleoutReadyTimeout = vsSeScaleoutReadyTimeout;
    return this;
  }

   /**
   * Timeout in seconds for Service Engine to sendScaleout Ready notification of a Virtual Service. Allowed values are 0-90. Field introduced in 18.1.5,18.2.1.
   * @return vsSeScaleoutReadyTimeout
  **/
  @Schema(description = "Timeout in seconds for Service Engine to sendScaleout Ready notification of a Virtual Service. Allowed values are 0-90. Field introduced in 18.1.5,18.2.1.")
  public Integer getVsSeScaleoutReadyTimeout() {
    return vsSeScaleoutReadyTimeout;
  }

  public void setVsSeScaleoutReadyTimeout(Integer vsSeScaleoutReadyTimeout) {
    this.vsSeScaleoutReadyTimeout = vsSeScaleoutReadyTimeout;
  }

  public ServiceEngineGroup vsSwitchoverTimeout(Integer vsSwitchoverTimeout) {
    this.vsSwitchoverTimeout = vsSwitchoverTimeout;
    return this;
  }

   /**
   * During SE upgrade in a legacy active/standby segroup, Time to wait for the new primary SE to accept flows before marking the switchover done. Field introduced in 17.2.13,18.1.4,18.2.1.
   * @return vsSwitchoverTimeout
  **/
  @Schema(description = "During SE upgrade in a legacy active/standby segroup, Time to wait for the new primary SE to accept flows before marking the switchover done. Field introduced in 17.2.13,18.1.4,18.2.1.")
  public Integer getVsSwitchoverTimeout() {
    return vsSwitchoverTimeout;
  }

  public void setVsSwitchoverTimeout(Integer vsSwitchoverTimeout) {
    this.vsSwitchoverTimeout = vsSwitchoverTimeout;
  }

  public ServiceEngineGroup vssPlacement(VssPlacement vssPlacement) {
    this.vssPlacement = vssPlacement;
    return this;
  }

   /**
   * Get vssPlacement
   * @return vssPlacement
  **/
  @Schema(description = "")
  public VssPlacement getVssPlacement() {
    return vssPlacement;
  }

  public void setVssPlacement(VssPlacement vssPlacement) {
    this.vssPlacement = vssPlacement;
  }

  public ServiceEngineGroup vssPlacementEnabled(Boolean vssPlacementEnabled) {
    this.vssPlacementEnabled = vssPlacementEnabled;
    return this;
  }

   /**
   * If set, Virtual Services will be placed on only a subset of the cores of an SE. Field introduced in 18.1.1.
   * @return vssPlacementEnabled
  **/
  @Schema(description = "If set, Virtual Services will be placed on only a subset of the cores of an SE. Field introduced in 18.1.1.")
  public Boolean isVssPlacementEnabled() {
    return vssPlacementEnabled;
  }

  public void setVssPlacementEnabled(Boolean vssPlacementEnabled) {
    this.vssPlacementEnabled = vssPlacementEnabled;
  }

  public ServiceEngineGroup wafLearningInterval(Integer wafLearningInterval) {
    this.wafLearningInterval = wafLearningInterval;
    return this;
  }

   /**
   * Frequency with which SE publishes WAF learning. Allowed values are 1-43200. Field deprecated in 18.2.3. Field introduced in 18.1.2.
   * @return wafLearningInterval
  **/
  @Schema(description = "Frequency with which SE publishes WAF learning. Allowed values are 1-43200. Field deprecated in 18.2.3. Field introduced in 18.1.2.")
  public Integer getWafLearningInterval() {
    return wafLearningInterval;
  }

  public void setWafLearningInterval(Integer wafLearningInterval) {
    this.wafLearningInterval = wafLearningInterval;
  }

  public ServiceEngineGroup wafLearningMemory(Integer wafLearningMemory) {
    this.wafLearningMemory = wafLearningMemory;
    return this;
  }

   /**
   * Amount of memory reserved on SE for WAF learning. This can be atmost 5% of SE memory. Field deprecated in 18.2.3. Field introduced in 18.1.2.
   * @return wafLearningMemory
  **/
  @Schema(description = "Amount of memory reserved on SE for WAF learning. This can be atmost 5% of SE memory. Field deprecated in 18.2.3. Field introduced in 18.1.2.")
  public Integer getWafLearningMemory() {
    return wafLearningMemory;
  }

  public void setWafLearningMemory(Integer wafLearningMemory) {
    this.wafLearningMemory = wafLearningMemory;
  }

  public ServiceEngineGroup wafMempool(Boolean wafMempool) {
    this.wafMempool = wafMempool;
    return this;
  }

   /**
   * Enable memory pool for WAF.Requires SE Reboot. Field introduced in 17.2.3.
   * @return wafMempool
  **/
  @Schema(description = "Enable memory pool for WAF.Requires SE Reboot. Field introduced in 17.2.3.")
  public Boolean isWafMempool() {
    return wafMempool;
  }

  public void setWafMempool(Boolean wafMempool) {
    this.wafMempool = wafMempool;
  }

  public ServiceEngineGroup wafMempoolSize(Integer wafMempoolSize) {
    this.wafMempoolSize = wafMempoolSize;
    return this;
  }

   /**
   * Memory pool size used for WAF.Requires SE Reboot. Field introduced in 17.2.3.
   * @return wafMempoolSize
  **/
  @Schema(description = "Memory pool size used for WAF.Requires SE Reboot. Field introduced in 17.2.3.")
  public Integer getWafMempoolSize() {
    return wafMempoolSize;
  }

  public void setWafMempoolSize(Integer wafMempoolSize) {
    this.wafMempoolSize = wafMempoolSize;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServiceEngineGroup serviceEngineGroup = (ServiceEngineGroup) o;
    return Objects.equals(this._lastModified, serviceEngineGroup._lastModified) &&
        Objects.equals(this.acceleratedNetworking, serviceEngineGroup.acceleratedNetworking) &&
        Objects.equals(this.activeStandby, serviceEngineGroup.activeStandby) &&
        Objects.equals(this.additionalConfigMemory, serviceEngineGroup.additionalConfigMemory) &&
        Objects.equals(this.advertiseBackendNetworks, serviceEngineGroup.advertiseBackendNetworks) &&
        Objects.equals(this.aggressiveFailureDetection, serviceEngineGroup.aggressiveFailureDetection) &&
        Objects.equals(this.algo, serviceEngineGroup.algo) &&
        Objects.equals(this.allowBurst, serviceEngineGroup.allowBurst) &&
        Objects.equals(this.appCachePercent, serviceEngineGroup.appCachePercent) &&
        Objects.equals(this.appCacheThreshold, serviceEngineGroup.appCacheThreshold) &&
        Objects.equals(this.appLearningMemoryPercent, serviceEngineGroup.appLearningMemoryPercent) &&
        Objects.equals(this.archiveShmLimit, serviceEngineGroup.archiveShmLimit) &&
        Objects.equals(this.asyncSsl, serviceEngineGroup.asyncSsl) &&
        Objects.equals(this.asyncSslThreads, serviceEngineGroup.asyncSslThreads) &&
        Objects.equals(this.autoRebalance, serviceEngineGroup.autoRebalance) &&
        Objects.equals(this.autoRebalanceCapacityPerSe, serviceEngineGroup.autoRebalanceCapacityPerSe) &&
        Objects.equals(this.autoRebalanceCriteria, serviceEngineGroup.autoRebalanceCriteria) &&
        Objects.equals(this.autoRebalanceInterval, serviceEngineGroup.autoRebalanceInterval) &&
        Objects.equals(this.autoRedistributeActiveStandbyLoad, serviceEngineGroup.autoRedistributeActiveStandbyLoad) &&
        Objects.equals(this.bgpStateUpdateInterval, serviceEngineGroup.bgpStateUpdateInterval) &&
        Objects.equals(this.bufferSe, serviceEngineGroup.bufferSe) &&
        Objects.equals(this.cloudRef, serviceEngineGroup.cloudRef) &&
        Objects.equals(this.configDebugsOnAllCores, serviceEngineGroup.configDebugsOnAllCores) &&
        Objects.equals(this.connectionMemoryPercentage, serviceEngineGroup.connectionMemoryPercentage) &&
        Objects.equals(this.coreShmAppCache, serviceEngineGroup.coreShmAppCache) &&
        Objects.equals(this.coreShmAppLearning, serviceEngineGroup.coreShmAppLearning) &&
        Objects.equals(this.cpuReserve, serviceEngineGroup.cpuReserve) &&
        Objects.equals(this.cpuSocketAffinity, serviceEngineGroup.cpuSocketAffinity) &&
        Objects.equals(this.customSecuritygroupsData, serviceEngineGroup.customSecuritygroupsData) &&
        Objects.equals(this.customSecuritygroupsMgmt, serviceEngineGroup.customSecuritygroupsMgmt) &&
        Objects.equals(this.customTag, serviceEngineGroup.customTag) &&
        Objects.equals(this.dataNetworkId, serviceEngineGroup.dataNetworkId) &&
        Objects.equals(this.datascriptTimeout, serviceEngineGroup.datascriptTimeout) &&
        Objects.equals(this.dedicatedDispatcherCore, serviceEngineGroup.dedicatedDispatcherCore) &&
        Objects.equals(this.description, serviceEngineGroup.description) &&
        Objects.equals(this.disableAviSecuritygroups, serviceEngineGroup.disableAviSecuritygroups) &&
        Objects.equals(this.disableCsumOffloads, serviceEngineGroup.disableCsumOffloads) &&
        Objects.equals(this.disableGro, serviceEngineGroup.disableGro) &&
        Objects.equals(this.disableSeMemoryCheck, serviceEngineGroup.disableSeMemoryCheck) &&
        Objects.equals(this.disableTso, serviceEngineGroup.disableTso) &&
        Objects.equals(this.diskPerSe, serviceEngineGroup.diskPerSe) &&
        Objects.equals(this.distributeLoadActiveStandby, serviceEngineGroup.distributeLoadActiveStandby) &&
        Objects.equals(this.distributeQueues, serviceEngineGroup.distributeQueues) &&
        Objects.equals(this.distributeVnics, serviceEngineGroup.distributeVnics) &&
        Objects.equals(this.enableGratarpPermanent, serviceEngineGroup.enableGratarpPermanent) &&
        Objects.equals(this.enableHsmPriming, serviceEngineGroup.enableHsmPriming) &&
        Objects.equals(this.enableMultiLb, serviceEngineGroup.enableMultiLb) &&
        Objects.equals(this.enablePcapTxRing, serviceEngineGroup.enablePcapTxRing) &&
        Objects.equals(this.enableRouting, serviceEngineGroup.enableRouting) &&
        Objects.equals(this.enableVipOnAllInterfaces, serviceEngineGroup.enableVipOnAllInterfaces) &&
        Objects.equals(this.enableVmac, serviceEngineGroup.enableVmac) &&
        Objects.equals(this.ephemeralPortrangeEnd, serviceEngineGroup.ephemeralPortrangeEnd) &&
        Objects.equals(this.ephemeralPortrangeStart, serviceEngineGroup.ephemeralPortrangeStart) &&
        Objects.equals(this.extraConfigMultiplier, serviceEngineGroup.extraConfigMultiplier) &&
        Objects.equals(this.extraSharedConfigMemory, serviceEngineGroup.extraSharedConfigMemory) &&
        Objects.equals(this.floatingIntfIp, serviceEngineGroup.floatingIntfIp) &&
        Objects.equals(this.floatingIntfIpSe2, serviceEngineGroup.floatingIntfIpSe2) &&
        Objects.equals(this.flowTableNewSynMaxEntries, serviceEngineGroup.flowTableNewSynMaxEntries) &&
        Objects.equals(this.freeListSize, serviceEngineGroup.freeListSize) &&
        Objects.equals(this.gratarpPermanentPeriodicity, serviceEngineGroup.gratarpPermanentPeriodicity) &&
        Objects.equals(this.haMode, serviceEngineGroup.haMode) &&
        Objects.equals(this.hardwaresecuritymodulegroupRef, serviceEngineGroup.hardwaresecuritymodulegroupRef) &&
        Objects.equals(this.heapMinimumConfigMemory, serviceEngineGroup.heapMinimumConfigMemory) &&
        Objects.equals(this.hmOnStandby, serviceEngineGroup.hmOnStandby) &&
        Objects.equals(this.hostAttributeKey, serviceEngineGroup.hostAttributeKey) &&
        Objects.equals(this.hostAttributeValue, serviceEngineGroup.hostAttributeValue) &&
        Objects.equals(this.hostGatewayMonitor, serviceEngineGroup.hostGatewayMonitor) &&
        Objects.equals(this.hypervisor, serviceEngineGroup.hypervisor) &&
        Objects.equals(this.ignoreRttThreshold, serviceEngineGroup.ignoreRttThreshold) &&
        Objects.equals(this.ingressAccessData, serviceEngineGroup.ingressAccessData) &&
        Objects.equals(this.ingressAccessMgmt, serviceEngineGroup.ingressAccessMgmt) &&
        Objects.equals(this.instanceFlavor, serviceEngineGroup.instanceFlavor) &&
        Objects.equals(this.iptables, serviceEngineGroup.iptables) &&
        Objects.equals(this.leastLoadCoreSelection, serviceEngineGroup.leastLoadCoreSelection) &&
        Objects.equals(this.licenseTier, serviceEngineGroup.licenseTier) &&
        Objects.equals(this.licenseType, serviceEngineGroup.licenseType) &&
        Objects.equals(this.logDisksz, serviceEngineGroup.logDisksz) &&
        Objects.equals(this.maxConcurrentExternalHm, serviceEngineGroup.maxConcurrentExternalHm) &&
        Objects.equals(this.maxCpuUsage, serviceEngineGroup.maxCpuUsage) &&
        Objects.equals(this.maxMemoryPerMempool, serviceEngineGroup.maxMemoryPerMempool) &&
        Objects.equals(this.maxNumSeDps, serviceEngineGroup.maxNumSeDps) &&
        Objects.equals(this.maxPublicIpsPerLb, serviceEngineGroup.maxPublicIpsPerLb) &&
        Objects.equals(this.maxQueuesPerVnic, serviceEngineGroup.maxQueuesPerVnic) &&
        Objects.equals(this.maxRulesPerLb, serviceEngineGroup.maxRulesPerLb) &&
        Objects.equals(this.maxScaleoutPerVs, serviceEngineGroup.maxScaleoutPerVs) &&
        Objects.equals(this.maxSe, serviceEngineGroup.maxSe) &&
        Objects.equals(this.maxVsPerSe, serviceEngineGroup.maxVsPerSe) &&
        Objects.equals(this.memReserve, serviceEngineGroup.memReserve) &&
        Objects.equals(this.memoryForConfigUpdate, serviceEngineGroup.memoryForConfigUpdate) &&
        Objects.equals(this.memoryPerSe, serviceEngineGroup.memoryPerSe) &&
        Objects.equals(this.mgmtNetworkRef, serviceEngineGroup.mgmtNetworkRef) &&
        Objects.equals(this.mgmtSubnet, serviceEngineGroup.mgmtSubnet) &&
        Objects.equals(this.minCpuUsage, serviceEngineGroup.minCpuUsage) &&
        Objects.equals(this.minScaleoutPerVs, serviceEngineGroup.minScaleoutPerVs) &&
        Objects.equals(this.minSe, serviceEngineGroup.minSe) &&
        Objects.equals(this.minimumConnectionMemory, serviceEngineGroup.minimumConnectionMemory) &&
        Objects.equals(this.minimumRequiredConfigMemory, serviceEngineGroup.minimumRequiredConfigMemory) &&
        Objects.equals(this.nLogStreamingThreads, serviceEngineGroup.nLogStreamingThreads) &&
        Objects.equals(this.name, serviceEngineGroup.name) &&
        Objects.equals(this.natFlowTcpClosedTimeout, serviceEngineGroup.natFlowTcpClosedTimeout) &&
        Objects.equals(this.natFlowTcpEstablishedTimeout, serviceEngineGroup.natFlowTcpEstablishedTimeout) &&
        Objects.equals(this.natFlowTcpHalfClosedTimeout, serviceEngineGroup.natFlowTcpHalfClosedTimeout) &&
        Objects.equals(this.natFlowTcpHandshakeTimeout, serviceEngineGroup.natFlowTcpHandshakeTimeout) &&
        Objects.equals(this.natFlowUdpNoresponseTimeout, serviceEngineGroup.natFlowUdpNoresponseTimeout) &&
        Objects.equals(this.natFlowUdpResponseTimeout, serviceEngineGroup.natFlowUdpResponseTimeout) &&
        Objects.equals(this.nonSignificantLogThrottle, serviceEngineGroup.nonSignificantLogThrottle) &&
        Objects.equals(this.numDispatcherCores, serviceEngineGroup.numDispatcherCores) &&
        Objects.equals(this.numFlowCoresSumChangesToIgnore, serviceEngineGroup.numFlowCoresSumChangesToIgnore) &&
        Objects.equals(this.openstackAvailabilityZone, serviceEngineGroup.openstackAvailabilityZone) &&
        Objects.equals(this.openstackAvailabilityZones, serviceEngineGroup.openstackAvailabilityZones) &&
        Objects.equals(this.openstackMgmtNetworkName, serviceEngineGroup.openstackMgmtNetworkName) &&
        Objects.equals(this.openstackMgmtNetworkUuid, serviceEngineGroup.openstackMgmtNetworkUuid) &&
        Objects.equals(this.osReservedMemory, serviceEngineGroup.osReservedMemory) &&
        Objects.equals(this.pcapTxMode, serviceEngineGroup.pcapTxMode) &&
        Objects.equals(this.perApp, serviceEngineGroup.perApp) &&
        Objects.equals(this.placementMode, serviceEngineGroup.placementMode) &&
        Objects.equals(this.realtimeSeMetrics, serviceEngineGroup.realtimeSeMetrics) &&
        Objects.equals(this.rebootOnPanic, serviceEngineGroup.rebootOnPanic) &&
        Objects.equals(this.rebootOnStop, serviceEngineGroup.rebootOnStop) &&
        Objects.equals(this.seBandwidthType, serviceEngineGroup.seBandwidthType) &&
        Objects.equals(this.seDeprovisionDelay, serviceEngineGroup.seDeprovisionDelay) &&
        Objects.equals(this.seDosProfile, serviceEngineGroup.seDosProfile) &&
        Objects.equals(this.seDpMaxHbVersion, serviceEngineGroup.seDpMaxHbVersion) &&
        Objects.equals(this.seDpVnicQueueStallEventSleep, serviceEngineGroup.seDpVnicQueueStallEventSleep) &&
        Objects.equals(this.seDpVnicQueueStallThreshold, serviceEngineGroup.seDpVnicQueueStallThreshold) &&
        Objects.equals(this.seDpVnicQueueStallTimeout, serviceEngineGroup.seDpVnicQueueStallTimeout) &&
        Objects.equals(this.seDpVnicRestartOnQueueStallCount, serviceEngineGroup.seDpVnicRestartOnQueueStallCount) &&
        Objects.equals(this.seDpVnicStallSeRestartWindow, serviceEngineGroup.seDpVnicStallSeRestartWindow) &&
        Objects.equals(this.seDpdkPmd, serviceEngineGroup.seDpdkPmd) &&
        Objects.equals(this.seFlowProbeRetries, serviceEngineGroup.seFlowProbeRetries) &&
        Objects.equals(this.seFlowProbeRetryTimer, serviceEngineGroup.seFlowProbeRetryTimer) &&
        Objects.equals(this.seFlowProbeTimer, serviceEngineGroup.seFlowProbeTimer) &&
        Objects.equals(this.seIpcUdpPort, serviceEngineGroup.seIpcUdpPort) &&
        Objects.equals(this.seKniBurstFactor, serviceEngineGroup.seKniBurstFactor) &&
        Objects.equals(this.seLro, serviceEngineGroup.seLro) &&
        Objects.equals(this.seMtu, serviceEngineGroup.seMtu) &&
        Objects.equals(this.seNamePrefix, serviceEngineGroup.seNamePrefix) &&
        Objects.equals(this.sePcapLookahead, serviceEngineGroup.sePcapLookahead) &&
        Objects.equals(this.sePcapPktCount, serviceEngineGroup.sePcapPktCount) &&
        Objects.equals(this.sePcapPktSz, serviceEngineGroup.sePcapPktSz) &&
        Objects.equals(this.sePcapQdiscBypass, serviceEngineGroup.sePcapQdiscBypass) &&
        Objects.equals(this.sePcapReinitFrequency, serviceEngineGroup.sePcapReinitFrequency) &&
        Objects.equals(this.sePcapReinitThreshold, serviceEngineGroup.sePcapReinitThreshold) &&
        Objects.equals(this.seProbePort, serviceEngineGroup.seProbePort) &&
        Objects.equals(this.seRemotePuntUdpPort, serviceEngineGroup.seRemotePuntUdpPort) &&
        Objects.equals(this.seRlProp, serviceEngineGroup.seRlProp) &&
        Objects.equals(this.seRouting, serviceEngineGroup.seRouting) &&
        Objects.equals(this.seRumSamplingNavInterval, serviceEngineGroup.seRumSamplingNavInterval) &&
        Objects.equals(this.seRumSamplingNavPercent, serviceEngineGroup.seRumSamplingNavPercent) &&
        Objects.equals(this.seRumSamplingResInterval, serviceEngineGroup.seRumSamplingResInterval) &&
        Objects.equals(this.seRumSamplingResPercent, serviceEngineGroup.seRumSamplingResPercent) &&
        Objects.equals(this.seSbDedicatedCore, serviceEngineGroup.seSbDedicatedCore) &&
        Objects.equals(this.seSbThreads, serviceEngineGroup.seSbThreads) &&
        Objects.equals(this.seThreadMultiplier, serviceEngineGroup.seThreadMultiplier) &&
        Objects.equals(this.seTracertPortRange, serviceEngineGroup.seTracertPortRange) &&
        Objects.equals(this.seTunnelMode, serviceEngineGroup.seTunnelMode) &&
        Objects.equals(this.seTunnelUdpPort, serviceEngineGroup.seTunnelUdpPort) &&
        Objects.equals(this.seTxBatchSize, serviceEngineGroup.seTxBatchSize) &&
        Objects.equals(this.seUdpEncapIpc, serviceEngineGroup.seUdpEncapIpc) &&
        Objects.equals(this.seUseDpdk, serviceEngineGroup.seUseDpdk) &&
        Objects.equals(this.seVsHbMaxPktsInBatch, serviceEngineGroup.seVsHbMaxPktsInBatch) &&
        Objects.equals(this.seVsHbMaxVsInPkt, serviceEngineGroup.seVsHbMaxVsInPkt) &&
        Objects.equals(this.selfSeElection, serviceEngineGroup.selfSeElection) &&
        Objects.equals(this.serviceIp6Subnets, serviceEngineGroup.serviceIp6Subnets) &&
        Objects.equals(this.serviceIpSubnets, serviceEngineGroup.serviceIpSubnets) &&
        Objects.equals(this.shmMinimumConfigMemory, serviceEngineGroup.shmMinimumConfigMemory) &&
        Objects.equals(this.significantLogThrottle, serviceEngineGroup.significantLogThrottle) &&
        Objects.equals(this.sslPreprocessSniHostname, serviceEngineGroup.sslPreprocessSniHostname) &&
        Objects.equals(this.tenantRef, serviceEngineGroup.tenantRef) &&
        Objects.equals(this.udfLogThrottle, serviceEngineGroup.udfLogThrottle) &&
        Objects.equals(this.url, serviceEngineGroup.url) &&
        Objects.equals(this.useStandardAlb, serviceEngineGroup.useStandardAlb) &&
        Objects.equals(this.uuid, serviceEngineGroup.uuid) &&
        Objects.equals(this.vcenterClusters, serviceEngineGroup.vcenterClusters) &&
        Objects.equals(this.vcenterDatastoreMode, serviceEngineGroup.vcenterDatastoreMode) &&
        Objects.equals(this.vcenterDatastores, serviceEngineGroup.vcenterDatastores) &&
        Objects.equals(this.vcenterDatastoresInclude, serviceEngineGroup.vcenterDatastoresInclude) &&
        Objects.equals(this.vcenterFolder, serviceEngineGroup.vcenterFolder) &&
        Objects.equals(this.vcenterHosts, serviceEngineGroup.vcenterHosts) &&
        Objects.equals(this.vcpusPerSe, serviceEngineGroup.vcpusPerSe) &&
        Objects.equals(this.vipAsg, serviceEngineGroup.vipAsg) &&
        Objects.equals(this.vsHostRedundancy, serviceEngineGroup.vsHostRedundancy) &&
        Objects.equals(this.vsScaleinTimeout, serviceEngineGroup.vsScaleinTimeout) &&
        Objects.equals(this.vsScaleinTimeoutForUpgrade, serviceEngineGroup.vsScaleinTimeoutForUpgrade) &&
        Objects.equals(this.vsScaleoutTimeout, serviceEngineGroup.vsScaleoutTimeout) &&
        Objects.equals(this.vsSeScaleoutAdditionalWaitTime, serviceEngineGroup.vsSeScaleoutAdditionalWaitTime) &&
        Objects.equals(this.vsSeScaleoutReadyTimeout, serviceEngineGroup.vsSeScaleoutReadyTimeout) &&
        Objects.equals(this.vsSwitchoverTimeout, serviceEngineGroup.vsSwitchoverTimeout) &&
        Objects.equals(this.vssPlacement, serviceEngineGroup.vssPlacement) &&
        Objects.equals(this.vssPlacementEnabled, serviceEngineGroup.vssPlacementEnabled) &&
        Objects.equals(this.wafLearningInterval, serviceEngineGroup.wafLearningInterval) &&
        Objects.equals(this.wafLearningMemory, serviceEngineGroup.wafLearningMemory) &&
        Objects.equals(this.wafMempool, serviceEngineGroup.wafMempool) &&
        Objects.equals(this.wafMempoolSize, serviceEngineGroup.wafMempoolSize);
  }

  @Override
  public int hashCode() {
    return Objects.hash(_lastModified, acceleratedNetworking, activeStandby, additionalConfigMemory, advertiseBackendNetworks, aggressiveFailureDetection, algo, allowBurst, appCachePercent, appCacheThreshold, appLearningMemoryPercent, archiveShmLimit, asyncSsl, asyncSslThreads, autoRebalance, autoRebalanceCapacityPerSe, autoRebalanceCriteria, autoRebalanceInterval, autoRedistributeActiveStandbyLoad, bgpStateUpdateInterval, bufferSe, cloudRef, configDebugsOnAllCores, connectionMemoryPercentage, coreShmAppCache, coreShmAppLearning, cpuReserve, cpuSocketAffinity, customSecuritygroupsData, customSecuritygroupsMgmt, customTag, dataNetworkId, datascriptTimeout, dedicatedDispatcherCore, description, disableAviSecuritygroups, disableCsumOffloads, disableGro, disableSeMemoryCheck, disableTso, diskPerSe, distributeLoadActiveStandby, distributeQueues, distributeVnics, enableGratarpPermanent, enableHsmPriming, enableMultiLb, enablePcapTxRing, enableRouting, enableVipOnAllInterfaces, enableVmac, ephemeralPortrangeEnd, ephemeralPortrangeStart, extraConfigMultiplier, extraSharedConfigMemory, floatingIntfIp, floatingIntfIpSe2, flowTableNewSynMaxEntries, freeListSize, gratarpPermanentPeriodicity, haMode, hardwaresecuritymodulegroupRef, heapMinimumConfigMemory, hmOnStandby, hostAttributeKey, hostAttributeValue, hostGatewayMonitor, hypervisor, ignoreRttThreshold, ingressAccessData, ingressAccessMgmt, instanceFlavor, iptables, leastLoadCoreSelection, licenseTier, licenseType, logDisksz, maxConcurrentExternalHm, maxCpuUsage, maxMemoryPerMempool, maxNumSeDps, maxPublicIpsPerLb, maxQueuesPerVnic, maxRulesPerLb, maxScaleoutPerVs, maxSe, maxVsPerSe, memReserve, memoryForConfigUpdate, memoryPerSe, mgmtNetworkRef, mgmtSubnet, minCpuUsage, minScaleoutPerVs, minSe, minimumConnectionMemory, minimumRequiredConfigMemory, nLogStreamingThreads, name, natFlowTcpClosedTimeout, natFlowTcpEstablishedTimeout, natFlowTcpHalfClosedTimeout, natFlowTcpHandshakeTimeout, natFlowUdpNoresponseTimeout, natFlowUdpResponseTimeout, nonSignificantLogThrottle, numDispatcherCores, numFlowCoresSumChangesToIgnore, openstackAvailabilityZone, openstackAvailabilityZones, openstackMgmtNetworkName, openstackMgmtNetworkUuid, osReservedMemory, pcapTxMode, perApp, placementMode, realtimeSeMetrics, rebootOnPanic, rebootOnStop, seBandwidthType, seDeprovisionDelay, seDosProfile, seDpMaxHbVersion, seDpVnicQueueStallEventSleep, seDpVnicQueueStallThreshold, seDpVnicQueueStallTimeout, seDpVnicRestartOnQueueStallCount, seDpVnicStallSeRestartWindow, seDpdkPmd, seFlowProbeRetries, seFlowProbeRetryTimer, seFlowProbeTimer, seIpcUdpPort, seKniBurstFactor, seLro, seMtu, seNamePrefix, sePcapLookahead, sePcapPktCount, sePcapPktSz, sePcapQdiscBypass, sePcapReinitFrequency, sePcapReinitThreshold, seProbePort, seRemotePuntUdpPort, seRlProp, seRouting, seRumSamplingNavInterval, seRumSamplingNavPercent, seRumSamplingResInterval, seRumSamplingResPercent, seSbDedicatedCore, seSbThreads, seThreadMultiplier, seTracertPortRange, seTunnelMode, seTunnelUdpPort, seTxBatchSize, seUdpEncapIpc, seUseDpdk, seVsHbMaxPktsInBatch, seVsHbMaxVsInPkt, selfSeElection, serviceIp6Subnets, serviceIpSubnets, shmMinimumConfigMemory, significantLogThrottle, sslPreprocessSniHostname, tenantRef, udfLogThrottle, url, useStandardAlb, uuid, vcenterClusters, vcenterDatastoreMode, vcenterDatastores, vcenterDatastoresInclude, vcenterFolder, vcenterHosts, vcpusPerSe, vipAsg, vsHostRedundancy, vsScaleinTimeout, vsScaleinTimeoutForUpgrade, vsScaleoutTimeout, vsSeScaleoutAdditionalWaitTime, vsSeScaleoutReadyTimeout, vsSwitchoverTimeout, vssPlacement, vssPlacementEnabled, wafLearningInterval, wafLearningMemory, wafMempool, wafMempoolSize);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServiceEngineGroup {\n");
    
    sb.append("    _lastModified: ").append(toIndentedString(_lastModified)).append("\n");
    sb.append("    acceleratedNetworking: ").append(toIndentedString(acceleratedNetworking)).append("\n");
    sb.append("    activeStandby: ").append(toIndentedString(activeStandby)).append("\n");
    sb.append("    additionalConfigMemory: ").append(toIndentedString(additionalConfigMemory)).append("\n");
    sb.append("    advertiseBackendNetworks: ").append(toIndentedString(advertiseBackendNetworks)).append("\n");
    sb.append("    aggressiveFailureDetection: ").append(toIndentedString(aggressiveFailureDetection)).append("\n");
    sb.append("    algo: ").append(toIndentedString(algo)).append("\n");
    sb.append("    allowBurst: ").append(toIndentedString(allowBurst)).append("\n");
    sb.append("    appCachePercent: ").append(toIndentedString(appCachePercent)).append("\n");
    sb.append("    appCacheThreshold: ").append(toIndentedString(appCacheThreshold)).append("\n");
    sb.append("    appLearningMemoryPercent: ").append(toIndentedString(appLearningMemoryPercent)).append("\n");
    sb.append("    archiveShmLimit: ").append(toIndentedString(archiveShmLimit)).append("\n");
    sb.append("    asyncSsl: ").append(toIndentedString(asyncSsl)).append("\n");
    sb.append("    asyncSslThreads: ").append(toIndentedString(asyncSslThreads)).append("\n");
    sb.append("    autoRebalance: ").append(toIndentedString(autoRebalance)).append("\n");
    sb.append("    autoRebalanceCapacityPerSe: ").append(toIndentedString(autoRebalanceCapacityPerSe)).append("\n");
    sb.append("    autoRebalanceCriteria: ").append(toIndentedString(autoRebalanceCriteria)).append("\n");
    sb.append("    autoRebalanceInterval: ").append(toIndentedString(autoRebalanceInterval)).append("\n");
    sb.append("    autoRedistributeActiveStandbyLoad: ").append(toIndentedString(autoRedistributeActiveStandbyLoad)).append("\n");
    sb.append("    bgpStateUpdateInterval: ").append(toIndentedString(bgpStateUpdateInterval)).append("\n");
    sb.append("    bufferSe: ").append(toIndentedString(bufferSe)).append("\n");
    sb.append("    cloudRef: ").append(toIndentedString(cloudRef)).append("\n");
    sb.append("    configDebugsOnAllCores: ").append(toIndentedString(configDebugsOnAllCores)).append("\n");
    sb.append("    connectionMemoryPercentage: ").append(toIndentedString(connectionMemoryPercentage)).append("\n");
    sb.append("    coreShmAppCache: ").append(toIndentedString(coreShmAppCache)).append("\n");
    sb.append("    coreShmAppLearning: ").append(toIndentedString(coreShmAppLearning)).append("\n");
    sb.append("    cpuReserve: ").append(toIndentedString(cpuReserve)).append("\n");
    sb.append("    cpuSocketAffinity: ").append(toIndentedString(cpuSocketAffinity)).append("\n");
    sb.append("    customSecuritygroupsData: ").append(toIndentedString(customSecuritygroupsData)).append("\n");
    sb.append("    customSecuritygroupsMgmt: ").append(toIndentedString(customSecuritygroupsMgmt)).append("\n");
    sb.append("    customTag: ").append(toIndentedString(customTag)).append("\n");
    sb.append("    dataNetworkId: ").append(toIndentedString(dataNetworkId)).append("\n");
    sb.append("    datascriptTimeout: ").append(toIndentedString(datascriptTimeout)).append("\n");
    sb.append("    dedicatedDispatcherCore: ").append(toIndentedString(dedicatedDispatcherCore)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    disableAviSecuritygroups: ").append(toIndentedString(disableAviSecuritygroups)).append("\n");
    sb.append("    disableCsumOffloads: ").append(toIndentedString(disableCsumOffloads)).append("\n");
    sb.append("    disableGro: ").append(toIndentedString(disableGro)).append("\n");
    sb.append("    disableSeMemoryCheck: ").append(toIndentedString(disableSeMemoryCheck)).append("\n");
    sb.append("    disableTso: ").append(toIndentedString(disableTso)).append("\n");
    sb.append("    diskPerSe: ").append(toIndentedString(diskPerSe)).append("\n");
    sb.append("    distributeLoadActiveStandby: ").append(toIndentedString(distributeLoadActiveStandby)).append("\n");
    sb.append("    distributeQueues: ").append(toIndentedString(distributeQueues)).append("\n");
    sb.append("    distributeVnics: ").append(toIndentedString(distributeVnics)).append("\n");
    sb.append("    enableGratarpPermanent: ").append(toIndentedString(enableGratarpPermanent)).append("\n");
    sb.append("    enableHsmPriming: ").append(toIndentedString(enableHsmPriming)).append("\n");
    sb.append("    enableMultiLb: ").append(toIndentedString(enableMultiLb)).append("\n");
    sb.append("    enablePcapTxRing: ").append(toIndentedString(enablePcapTxRing)).append("\n");
    sb.append("    enableRouting: ").append(toIndentedString(enableRouting)).append("\n");
    sb.append("    enableVipOnAllInterfaces: ").append(toIndentedString(enableVipOnAllInterfaces)).append("\n");
    sb.append("    enableVmac: ").append(toIndentedString(enableVmac)).append("\n");
    sb.append("    ephemeralPortrangeEnd: ").append(toIndentedString(ephemeralPortrangeEnd)).append("\n");
    sb.append("    ephemeralPortrangeStart: ").append(toIndentedString(ephemeralPortrangeStart)).append("\n");
    sb.append("    extraConfigMultiplier: ").append(toIndentedString(extraConfigMultiplier)).append("\n");
    sb.append("    extraSharedConfigMemory: ").append(toIndentedString(extraSharedConfigMemory)).append("\n");
    sb.append("    floatingIntfIp: ").append(toIndentedString(floatingIntfIp)).append("\n");
    sb.append("    floatingIntfIpSe2: ").append(toIndentedString(floatingIntfIpSe2)).append("\n");
    sb.append("    flowTableNewSynMaxEntries: ").append(toIndentedString(flowTableNewSynMaxEntries)).append("\n");
    sb.append("    freeListSize: ").append(toIndentedString(freeListSize)).append("\n");
    sb.append("    gratarpPermanentPeriodicity: ").append(toIndentedString(gratarpPermanentPeriodicity)).append("\n");
    sb.append("    haMode: ").append(toIndentedString(haMode)).append("\n");
    sb.append("    hardwaresecuritymodulegroupRef: ").append(toIndentedString(hardwaresecuritymodulegroupRef)).append("\n");
    sb.append("    heapMinimumConfigMemory: ").append(toIndentedString(heapMinimumConfigMemory)).append("\n");
    sb.append("    hmOnStandby: ").append(toIndentedString(hmOnStandby)).append("\n");
    sb.append("    hostAttributeKey: ").append(toIndentedString(hostAttributeKey)).append("\n");
    sb.append("    hostAttributeValue: ").append(toIndentedString(hostAttributeValue)).append("\n");
    sb.append("    hostGatewayMonitor: ").append(toIndentedString(hostGatewayMonitor)).append("\n");
    sb.append("    hypervisor: ").append(toIndentedString(hypervisor)).append("\n");
    sb.append("    ignoreRttThreshold: ").append(toIndentedString(ignoreRttThreshold)).append("\n");
    sb.append("    ingressAccessData: ").append(toIndentedString(ingressAccessData)).append("\n");
    sb.append("    ingressAccessMgmt: ").append(toIndentedString(ingressAccessMgmt)).append("\n");
    sb.append("    instanceFlavor: ").append(toIndentedString(instanceFlavor)).append("\n");
    sb.append("    iptables: ").append(toIndentedString(iptables)).append("\n");
    sb.append("    leastLoadCoreSelection: ").append(toIndentedString(leastLoadCoreSelection)).append("\n");
    sb.append("    licenseTier: ").append(toIndentedString(licenseTier)).append("\n");
    sb.append("    licenseType: ").append(toIndentedString(licenseType)).append("\n");
    sb.append("    logDisksz: ").append(toIndentedString(logDisksz)).append("\n");
    sb.append("    maxConcurrentExternalHm: ").append(toIndentedString(maxConcurrentExternalHm)).append("\n");
    sb.append("    maxCpuUsage: ").append(toIndentedString(maxCpuUsage)).append("\n");
    sb.append("    maxMemoryPerMempool: ").append(toIndentedString(maxMemoryPerMempool)).append("\n");
    sb.append("    maxNumSeDps: ").append(toIndentedString(maxNumSeDps)).append("\n");
    sb.append("    maxPublicIpsPerLb: ").append(toIndentedString(maxPublicIpsPerLb)).append("\n");
    sb.append("    maxQueuesPerVnic: ").append(toIndentedString(maxQueuesPerVnic)).append("\n");
    sb.append("    maxRulesPerLb: ").append(toIndentedString(maxRulesPerLb)).append("\n");
    sb.append("    maxScaleoutPerVs: ").append(toIndentedString(maxScaleoutPerVs)).append("\n");
    sb.append("    maxSe: ").append(toIndentedString(maxSe)).append("\n");
    sb.append("    maxVsPerSe: ").append(toIndentedString(maxVsPerSe)).append("\n");
    sb.append("    memReserve: ").append(toIndentedString(memReserve)).append("\n");
    sb.append("    memoryForConfigUpdate: ").append(toIndentedString(memoryForConfigUpdate)).append("\n");
    sb.append("    memoryPerSe: ").append(toIndentedString(memoryPerSe)).append("\n");
    sb.append("    mgmtNetworkRef: ").append(toIndentedString(mgmtNetworkRef)).append("\n");
    sb.append("    mgmtSubnet: ").append(toIndentedString(mgmtSubnet)).append("\n");
    sb.append("    minCpuUsage: ").append(toIndentedString(minCpuUsage)).append("\n");
    sb.append("    minScaleoutPerVs: ").append(toIndentedString(minScaleoutPerVs)).append("\n");
    sb.append("    minSe: ").append(toIndentedString(minSe)).append("\n");
    sb.append("    minimumConnectionMemory: ").append(toIndentedString(minimumConnectionMemory)).append("\n");
    sb.append("    minimumRequiredConfigMemory: ").append(toIndentedString(minimumRequiredConfigMemory)).append("\n");
    sb.append("    nLogStreamingThreads: ").append(toIndentedString(nLogStreamingThreads)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    natFlowTcpClosedTimeout: ").append(toIndentedString(natFlowTcpClosedTimeout)).append("\n");
    sb.append("    natFlowTcpEstablishedTimeout: ").append(toIndentedString(natFlowTcpEstablishedTimeout)).append("\n");
    sb.append("    natFlowTcpHalfClosedTimeout: ").append(toIndentedString(natFlowTcpHalfClosedTimeout)).append("\n");
    sb.append("    natFlowTcpHandshakeTimeout: ").append(toIndentedString(natFlowTcpHandshakeTimeout)).append("\n");
    sb.append("    natFlowUdpNoresponseTimeout: ").append(toIndentedString(natFlowUdpNoresponseTimeout)).append("\n");
    sb.append("    natFlowUdpResponseTimeout: ").append(toIndentedString(natFlowUdpResponseTimeout)).append("\n");
    sb.append("    nonSignificantLogThrottle: ").append(toIndentedString(nonSignificantLogThrottle)).append("\n");
    sb.append("    numDispatcherCores: ").append(toIndentedString(numDispatcherCores)).append("\n");
    sb.append("    numFlowCoresSumChangesToIgnore: ").append(toIndentedString(numFlowCoresSumChangesToIgnore)).append("\n");
    sb.append("    openstackAvailabilityZone: ").append(toIndentedString(openstackAvailabilityZone)).append("\n");
    sb.append("    openstackAvailabilityZones: ").append(toIndentedString(openstackAvailabilityZones)).append("\n");
    sb.append("    openstackMgmtNetworkName: ").append(toIndentedString(openstackMgmtNetworkName)).append("\n");
    sb.append("    openstackMgmtNetworkUuid: ").append(toIndentedString(openstackMgmtNetworkUuid)).append("\n");
    sb.append("    osReservedMemory: ").append(toIndentedString(osReservedMemory)).append("\n");
    sb.append("    pcapTxMode: ").append(toIndentedString(pcapTxMode)).append("\n");
    sb.append("    perApp: ").append(toIndentedString(perApp)).append("\n");
    sb.append("    placementMode: ").append(toIndentedString(placementMode)).append("\n");
    sb.append("    realtimeSeMetrics: ").append(toIndentedString(realtimeSeMetrics)).append("\n");
    sb.append("    rebootOnPanic: ").append(toIndentedString(rebootOnPanic)).append("\n");
    sb.append("    rebootOnStop: ").append(toIndentedString(rebootOnStop)).append("\n");
    sb.append("    seBandwidthType: ").append(toIndentedString(seBandwidthType)).append("\n");
    sb.append("    seDeprovisionDelay: ").append(toIndentedString(seDeprovisionDelay)).append("\n");
    sb.append("    seDosProfile: ").append(toIndentedString(seDosProfile)).append("\n");
    sb.append("    seDpMaxHbVersion: ").append(toIndentedString(seDpMaxHbVersion)).append("\n");
    sb.append("    seDpVnicQueueStallEventSleep: ").append(toIndentedString(seDpVnicQueueStallEventSleep)).append("\n");
    sb.append("    seDpVnicQueueStallThreshold: ").append(toIndentedString(seDpVnicQueueStallThreshold)).append("\n");
    sb.append("    seDpVnicQueueStallTimeout: ").append(toIndentedString(seDpVnicQueueStallTimeout)).append("\n");
    sb.append("    seDpVnicRestartOnQueueStallCount: ").append(toIndentedString(seDpVnicRestartOnQueueStallCount)).append("\n");
    sb.append("    seDpVnicStallSeRestartWindow: ").append(toIndentedString(seDpVnicStallSeRestartWindow)).append("\n");
    sb.append("    seDpdkPmd: ").append(toIndentedString(seDpdkPmd)).append("\n");
    sb.append("    seFlowProbeRetries: ").append(toIndentedString(seFlowProbeRetries)).append("\n");
    sb.append("    seFlowProbeRetryTimer: ").append(toIndentedString(seFlowProbeRetryTimer)).append("\n");
    sb.append("    seFlowProbeTimer: ").append(toIndentedString(seFlowProbeTimer)).append("\n");
    sb.append("    seIpcUdpPort: ").append(toIndentedString(seIpcUdpPort)).append("\n");
    sb.append("    seKniBurstFactor: ").append(toIndentedString(seKniBurstFactor)).append("\n");
    sb.append("    seLro: ").append(toIndentedString(seLro)).append("\n");
    sb.append("    seMtu: ").append(toIndentedString(seMtu)).append("\n");
    sb.append("    seNamePrefix: ").append(toIndentedString(seNamePrefix)).append("\n");
    sb.append("    sePcapLookahead: ").append(toIndentedString(sePcapLookahead)).append("\n");
    sb.append("    sePcapPktCount: ").append(toIndentedString(sePcapPktCount)).append("\n");
    sb.append("    sePcapPktSz: ").append(toIndentedString(sePcapPktSz)).append("\n");
    sb.append("    sePcapQdiscBypass: ").append(toIndentedString(sePcapQdiscBypass)).append("\n");
    sb.append("    sePcapReinitFrequency: ").append(toIndentedString(sePcapReinitFrequency)).append("\n");
    sb.append("    sePcapReinitThreshold: ").append(toIndentedString(sePcapReinitThreshold)).append("\n");
    sb.append("    seProbePort: ").append(toIndentedString(seProbePort)).append("\n");
    sb.append("    seRemotePuntUdpPort: ").append(toIndentedString(seRemotePuntUdpPort)).append("\n");
    sb.append("    seRlProp: ").append(toIndentedString(seRlProp)).append("\n");
    sb.append("    seRouting: ").append(toIndentedString(seRouting)).append("\n");
    sb.append("    seRumSamplingNavInterval: ").append(toIndentedString(seRumSamplingNavInterval)).append("\n");
    sb.append("    seRumSamplingNavPercent: ").append(toIndentedString(seRumSamplingNavPercent)).append("\n");
    sb.append("    seRumSamplingResInterval: ").append(toIndentedString(seRumSamplingResInterval)).append("\n");
    sb.append("    seRumSamplingResPercent: ").append(toIndentedString(seRumSamplingResPercent)).append("\n");
    sb.append("    seSbDedicatedCore: ").append(toIndentedString(seSbDedicatedCore)).append("\n");
    sb.append("    seSbThreads: ").append(toIndentedString(seSbThreads)).append("\n");
    sb.append("    seThreadMultiplier: ").append(toIndentedString(seThreadMultiplier)).append("\n");
    sb.append("    seTracertPortRange: ").append(toIndentedString(seTracertPortRange)).append("\n");
    sb.append("    seTunnelMode: ").append(toIndentedString(seTunnelMode)).append("\n");
    sb.append("    seTunnelUdpPort: ").append(toIndentedString(seTunnelUdpPort)).append("\n");
    sb.append("    seTxBatchSize: ").append(toIndentedString(seTxBatchSize)).append("\n");
    sb.append("    seUdpEncapIpc: ").append(toIndentedString(seUdpEncapIpc)).append("\n");
    sb.append("    seUseDpdk: ").append(toIndentedString(seUseDpdk)).append("\n");
    sb.append("    seVsHbMaxPktsInBatch: ").append(toIndentedString(seVsHbMaxPktsInBatch)).append("\n");
    sb.append("    seVsHbMaxVsInPkt: ").append(toIndentedString(seVsHbMaxVsInPkt)).append("\n");
    sb.append("    selfSeElection: ").append(toIndentedString(selfSeElection)).append("\n");
    sb.append("    serviceIp6Subnets: ").append(toIndentedString(serviceIp6Subnets)).append("\n");
    sb.append("    serviceIpSubnets: ").append(toIndentedString(serviceIpSubnets)).append("\n");
    sb.append("    shmMinimumConfigMemory: ").append(toIndentedString(shmMinimumConfigMemory)).append("\n");
    sb.append("    significantLogThrottle: ").append(toIndentedString(significantLogThrottle)).append("\n");
    sb.append("    sslPreprocessSniHostname: ").append(toIndentedString(sslPreprocessSniHostname)).append("\n");
    sb.append("    tenantRef: ").append(toIndentedString(tenantRef)).append("\n");
    sb.append("    udfLogThrottle: ").append(toIndentedString(udfLogThrottle)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    useStandardAlb: ").append(toIndentedString(useStandardAlb)).append("\n");
    sb.append("    uuid: ").append(toIndentedString(uuid)).append("\n");
    sb.append("    vcenterClusters: ").append(toIndentedString(vcenterClusters)).append("\n");
    sb.append("    vcenterDatastoreMode: ").append(toIndentedString(vcenterDatastoreMode)).append("\n");
    sb.append("    vcenterDatastores: ").append(toIndentedString(vcenterDatastores)).append("\n");
    sb.append("    vcenterDatastoresInclude: ").append(toIndentedString(vcenterDatastoresInclude)).append("\n");
    sb.append("    vcenterFolder: ").append(toIndentedString(vcenterFolder)).append("\n");
    sb.append("    vcenterHosts: ").append(toIndentedString(vcenterHosts)).append("\n");
    sb.append("    vcpusPerSe: ").append(toIndentedString(vcpusPerSe)).append("\n");
    sb.append("    vipAsg: ").append(toIndentedString(vipAsg)).append("\n");
    sb.append("    vsHostRedundancy: ").append(toIndentedString(vsHostRedundancy)).append("\n");
    sb.append("    vsScaleinTimeout: ").append(toIndentedString(vsScaleinTimeout)).append("\n");
    sb.append("    vsScaleinTimeoutForUpgrade: ").append(toIndentedString(vsScaleinTimeoutForUpgrade)).append("\n");
    sb.append("    vsScaleoutTimeout: ").append(toIndentedString(vsScaleoutTimeout)).append("\n");
    sb.append("    vsSeScaleoutAdditionalWaitTime: ").append(toIndentedString(vsSeScaleoutAdditionalWaitTime)).append("\n");
    sb.append("    vsSeScaleoutReadyTimeout: ").append(toIndentedString(vsSeScaleoutReadyTimeout)).append("\n");
    sb.append("    vsSwitchoverTimeout: ").append(toIndentedString(vsSwitchoverTimeout)).append("\n");
    sb.append("    vssPlacement: ").append(toIndentedString(vssPlacement)).append("\n");
    sb.append("    vssPlacementEnabled: ").append(toIndentedString(vssPlacementEnabled)).append("\n");
    sb.append("    wafLearningInterval: ").append(toIndentedString(wafLearningInterval)).append("\n");
    sb.append("    wafLearningMemory: ").append(toIndentedString(wafLearningMemory)).append("\n");
    sb.append("    wafMempool: ").append(toIndentedString(wafMempool)).append("\n");
    sb.append("    wafMempoolSize: ").append(toIndentedString(wafMempoolSize)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
