/*
 * Avi avi_global_spec Object API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 20.1.1
 * Contact: support@avinetworks.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.vmware.avi.sdk.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.vmware.avi.sdk.model.DockerRegistry;
import com.vmware.avi.sdk.model.IpAddrPrefix;
import com.vmware.avi.sdk.model.MesosAttribute;
import com.vmware.avi.sdk.model.SSHSeDeployment;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.List;
/**
 * DockerConfiguration
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-12T12:27:26.755+05:30[Asia/Kolkata]")
public class DockerConfiguration {
  @JsonProperty("app_sync_frequency")
  private Integer appSyncFrequency = 60;

  @JsonProperty("ca_tls_key_and_certificate_ref")
  private String caTlsKeyAndCertificateRef = null;

  @JsonProperty("client_tls_key_and_certificate_ref")
  private String clientTlsKeyAndCertificateRef = null;

  @JsonProperty("container_port_match_http_service")
  private Boolean containerPortMatchHttpService = true;

  @JsonProperty("coredump_directory")
  private String coredumpDirectory = "/var/lib/systemd/coredump";

  @JsonProperty("disable_auto_backend_service_sync")
  private Boolean disableAutoBackendServiceSync = null;

  @JsonProperty("disable_auto_frontend_service_sync")
  private Boolean disableAutoFrontendServiceSync = null;

  @JsonProperty("disable_auto_se_creation")
  private Boolean disableAutoSeCreation = null;

  @JsonProperty("docker_registry_se")
  private DockerRegistry dockerRegistrySe = null;

  @JsonProperty("east_west_placement_subnet")
  private IpAddrPrefix eastWestPlacementSubnet = null;

  @JsonProperty("enable_event_subscription")
  private Boolean enableEventSubscription = true;

  @JsonProperty("feproxy_container_port_as_service")
  private Boolean feproxyContainerPortAsService = null;

  @JsonProperty("feproxy_vips_enable_proxy_arp")
  private Boolean feproxyVipsEnableProxyArp = true;

  @JsonProperty("fleet_endpoint")
  private String fleetEndpoint = null;

  @JsonProperty("http_container_ports")
  private List<Integer> httpContainerPorts = null;

  @JsonProperty("se_deployment_method")
  private String seDeploymentMethod = "SE_CREATE_SSH";

  @JsonProperty("se_exclude_attributes")
  private List<MesosAttribute> seExcludeAttributes = null;

  @JsonProperty("se_include_attributes")
  private List<MesosAttribute> seIncludeAttributes = null;

  @JsonProperty("se_spawn_rate")
  private Integer seSpawnRate = 25;

  @JsonProperty("se_volume")
  private String seVolume = "/opt/avi";

  @JsonProperty("services_accessible_all_interfaces")
  private Boolean servicesAccessibleAllInterfaces = null;

  @JsonProperty("ssh_se_deployment")
  private SSHSeDeployment sshSeDeployment = null;

  @JsonProperty("ssh_user_ref")
  private String sshUserRef = null;

  @JsonProperty("ucp_nodes")
  private List<String> ucpNodes = null;

  @JsonProperty("use_container_ip_port")
  private Boolean useContainerIpPort = null;

  @JsonProperty("use_controller_image")
  private Boolean useControllerImage = null;

  public DockerConfiguration appSyncFrequency(Integer appSyncFrequency) {
    this.appSyncFrequency = appSyncFrequency;
    return this;
  }

   /**
   * Sync frequency in seconds with frameworks.
   * @return appSyncFrequency
  **/
  @Schema(description = "Sync frequency in seconds with frameworks.")
  public Integer getAppSyncFrequency() {
    return appSyncFrequency;
  }

  public void setAppSyncFrequency(Integer appSyncFrequency) {
    this.appSyncFrequency = appSyncFrequency;
  }

  public DockerConfiguration caTlsKeyAndCertificateRef(String caTlsKeyAndCertificateRef) {
    this.caTlsKeyAndCertificateRef = caTlsKeyAndCertificateRef;
    return this;
  }

   /**
   * UUID of the UCP CA TLS cert and key. It is a reference to an object of type SSLKeyAndCertificate.
   * @return caTlsKeyAndCertificateRef
  **/
  @Schema(description = "UUID of the UCP CA TLS cert and key. It is a reference to an object of type SSLKeyAndCertificate.")
  public String getCaTlsKeyAndCertificateRef() {
    return caTlsKeyAndCertificateRef;
  }

  public void setCaTlsKeyAndCertificateRef(String caTlsKeyAndCertificateRef) {
    this.caTlsKeyAndCertificateRef = caTlsKeyAndCertificateRef;
  }

  public DockerConfiguration clientTlsKeyAndCertificateRef(String clientTlsKeyAndCertificateRef) {
    this.clientTlsKeyAndCertificateRef = clientTlsKeyAndCertificateRef;
    return this;
  }

   /**
   * UUID of the client TLS cert and key. It is a reference to an object of type SSLKeyAndCertificate.
   * @return clientTlsKeyAndCertificateRef
  **/
  @Schema(description = "UUID of the client TLS cert and key. It is a reference to an object of type SSLKeyAndCertificate.")
  public String getClientTlsKeyAndCertificateRef() {
    return clientTlsKeyAndCertificateRef;
  }

  public void setClientTlsKeyAndCertificateRef(String clientTlsKeyAndCertificateRef) {
    this.clientTlsKeyAndCertificateRef = clientTlsKeyAndCertificateRef;
  }

  public DockerConfiguration containerPortMatchHttpService(Boolean containerPortMatchHttpService) {
    this.containerPortMatchHttpService = containerPortMatchHttpService;
    return this;
  }

   /**
   * Perform container port matching to create a HTTP Virtualservice instead of a TCP/UDP VirtualService.
   * @return containerPortMatchHttpService
  **/
  @Schema(description = "Perform container port matching to create a HTTP Virtualservice instead of a TCP/UDP VirtualService.")
  public Boolean isContainerPortMatchHttpService() {
    return containerPortMatchHttpService;
  }

  public void setContainerPortMatchHttpService(Boolean containerPortMatchHttpService) {
    this.containerPortMatchHttpService = containerPortMatchHttpService;
  }

  public DockerConfiguration coredumpDirectory(String coredumpDirectory) {
    this.coredumpDirectory = coredumpDirectory;
    return this;
  }

   /**
   * Directory to mount to check for core dumps on Service Engines. This will be mapped read only to /var/crash on any new Service Engines. This is a disruptive change.
   * @return coredumpDirectory
  **/
  @Schema(description = "Directory to mount to check for core dumps on Service Engines. This will be mapped read only to /var/crash on any new Service Engines. This is a disruptive change.")
  public String getCoredumpDirectory() {
    return coredumpDirectory;
  }

  public void setCoredumpDirectory(String coredumpDirectory) {
    this.coredumpDirectory = coredumpDirectory;
  }

  public DockerConfiguration disableAutoBackendServiceSync(Boolean disableAutoBackendServiceSync) {
    this.disableAutoBackendServiceSync = disableAutoBackendServiceSync;
    return this;
  }

   /**
   * Disable auto service sync for back end services.
   * @return disableAutoBackendServiceSync
  **/
  @Schema(description = "Disable auto service sync for back end services.")
  public Boolean isDisableAutoBackendServiceSync() {
    return disableAutoBackendServiceSync;
  }

  public void setDisableAutoBackendServiceSync(Boolean disableAutoBackendServiceSync) {
    this.disableAutoBackendServiceSync = disableAutoBackendServiceSync;
  }

  public DockerConfiguration disableAutoFrontendServiceSync(Boolean disableAutoFrontendServiceSync) {
    this.disableAutoFrontendServiceSync = disableAutoFrontendServiceSync;
    return this;
  }

   /**
   * Disable auto service sync for front end services.
   * @return disableAutoFrontendServiceSync
  **/
  @Schema(description = "Disable auto service sync for front end services.")
  public Boolean isDisableAutoFrontendServiceSync() {
    return disableAutoFrontendServiceSync;
  }

  public void setDisableAutoFrontendServiceSync(Boolean disableAutoFrontendServiceSync) {
    this.disableAutoFrontendServiceSync = disableAutoFrontendServiceSync;
  }

  public DockerConfiguration disableAutoSeCreation(Boolean disableAutoSeCreation) {
    this.disableAutoSeCreation = disableAutoSeCreation;
    return this;
  }

   /**
   * Disable SE creation.
   * @return disableAutoSeCreation
  **/
  @Schema(description = "Disable SE creation.")
  public Boolean isDisableAutoSeCreation() {
    return disableAutoSeCreation;
  }

  public void setDisableAutoSeCreation(Boolean disableAutoSeCreation) {
    this.disableAutoSeCreation = disableAutoSeCreation;
  }

  public DockerConfiguration dockerRegistrySe(DockerRegistry dockerRegistrySe) {
    this.dockerRegistrySe = dockerRegistrySe;
    return this;
  }

   /**
   * Get dockerRegistrySe
   * @return dockerRegistrySe
  **/
  @Schema(description = "")
  public DockerRegistry getDockerRegistrySe() {
    return dockerRegistrySe;
  }

  public void setDockerRegistrySe(DockerRegistry dockerRegistrySe) {
    this.dockerRegistrySe = dockerRegistrySe;
  }

  public DockerConfiguration eastWestPlacementSubnet(IpAddrPrefix eastWestPlacementSubnet) {
    this.eastWestPlacementSubnet = eastWestPlacementSubnet;
    return this;
  }

   /**
   * Get eastWestPlacementSubnet
   * @return eastWestPlacementSubnet
  **/
  @Schema(description = "")
  public IpAddrPrefix getEastWestPlacementSubnet() {
    return eastWestPlacementSubnet;
  }

  public void setEastWestPlacementSubnet(IpAddrPrefix eastWestPlacementSubnet) {
    this.eastWestPlacementSubnet = eastWestPlacementSubnet;
  }

  public DockerConfiguration enableEventSubscription(Boolean enableEventSubscription) {
    this.enableEventSubscription = enableEventSubscription;
    return this;
  }

   /**
   * Enable Docker event subscription.
   * @return enableEventSubscription
  **/
  @Schema(description = "Enable Docker event subscription.")
  public Boolean isEnableEventSubscription() {
    return enableEventSubscription;
  }

  public void setEnableEventSubscription(Boolean enableEventSubscription) {
    this.enableEventSubscription = enableEventSubscription;
  }

  public DockerConfiguration feproxyContainerPortAsService(Boolean feproxyContainerPortAsService) {
    this.feproxyContainerPortAsService = feproxyContainerPortAsService;
    return this;
  }

   /**
   * For Front End proxies, use container port as service port.
   * @return feproxyContainerPortAsService
  **/
  @Schema(description = "For Front End proxies, use container port as service port.")
  public Boolean isFeproxyContainerPortAsService() {
    return feproxyContainerPortAsService;
  }

  public void setFeproxyContainerPortAsService(Boolean feproxyContainerPortAsService) {
    this.feproxyContainerPortAsService = feproxyContainerPortAsService;
  }

  public DockerConfiguration feproxyVipsEnableProxyArp(Boolean feproxyVipsEnableProxyArp) {
    this.feproxyVipsEnableProxyArp = feproxyVipsEnableProxyArp;
    return this;
  }

   /**
   * Enable proxy ARP from Host interface for Front End  proxies.
   * @return feproxyVipsEnableProxyArp
  **/
  @Schema(description = "Enable proxy ARP from Host interface for Front End  proxies.")
  public Boolean isFeproxyVipsEnableProxyArp() {
    return feproxyVipsEnableProxyArp;
  }

  public void setFeproxyVipsEnableProxyArp(Boolean feproxyVipsEnableProxyArp) {
    this.feproxyVipsEnableProxyArp = feproxyVipsEnableProxyArp;
  }

  public DockerConfiguration fleetEndpoint(String fleetEndpoint) {
    this.fleetEndpoint = fleetEndpoint;
    return this;
  }

   /**
   * Optional fleet remote endpoint if fleet is used for SE deployment.
   * @return fleetEndpoint
  **/
  @Schema(description = "Optional fleet remote endpoint if fleet is used for SE deployment.")
  public String getFleetEndpoint() {
    return fleetEndpoint;
  }

  public void setFleetEndpoint(String fleetEndpoint) {
    this.fleetEndpoint = fleetEndpoint;
  }

  public DockerConfiguration httpContainerPorts(List<Integer> httpContainerPorts) {
    this.httpContainerPorts = httpContainerPorts;
    return this;
  }

  public DockerConfiguration addHttpContainerPortsItem(Integer httpContainerPortsItem) {
    if (this.httpContainerPorts == null) {
      this.httpContainerPorts = new ArrayList<Integer>();
    }
    this.httpContainerPorts.add(httpContainerPortsItem);
    return this;
  }

   /**
   * List of container ports that create a HTTP Virtualservice instead of a TCP/UDP VirtualService. Defaults to 80.
   * @return httpContainerPorts
  **/
  @Schema(description = "List of container ports that create a HTTP Virtualservice instead of a TCP/UDP VirtualService. Defaults to 80.")
  public List<Integer> getHttpContainerPorts() {
    return httpContainerPorts;
  }

  public void setHttpContainerPorts(List<Integer> httpContainerPorts) {
    this.httpContainerPorts = httpContainerPorts;
  }

  public DockerConfiguration seDeploymentMethod(String seDeploymentMethod) {
    this.seDeploymentMethod = seDeploymentMethod;
    return this;
  }

   /**
   * Use Fleet/SSH for SE deployment. Enum options - SE_CREATE_FLEET, SE_CREATE_SSH, SE_CREATE_POD.
   * @return seDeploymentMethod
  **/
  @Schema(description = "Use Fleet/SSH for SE deployment. Enum options - SE_CREATE_FLEET, SE_CREATE_SSH, SE_CREATE_POD.")
  public String getSeDeploymentMethod() {
    return seDeploymentMethod;
  }

  public void setSeDeploymentMethod(String seDeploymentMethod) {
    this.seDeploymentMethod = seDeploymentMethod;
  }

  public DockerConfiguration seExcludeAttributes(List<MesosAttribute> seExcludeAttributes) {
    this.seExcludeAttributes = seExcludeAttributes;
    return this;
  }

  public DockerConfiguration addSeExcludeAttributesItem(MesosAttribute seExcludeAttributesItem) {
    if (this.seExcludeAttributes == null) {
      this.seExcludeAttributes = new ArrayList<MesosAttribute>();
    }
    this.seExcludeAttributes.add(seExcludeAttributesItem);
    return this;
  }

   /**
   * Exclude hosts with attributes for SE creation.
   * @return seExcludeAttributes
  **/
  @Schema(description = "Exclude hosts with attributes for SE creation.")
  public List<MesosAttribute> getSeExcludeAttributes() {
    return seExcludeAttributes;
  }

  public void setSeExcludeAttributes(List<MesosAttribute> seExcludeAttributes) {
    this.seExcludeAttributes = seExcludeAttributes;
  }

  public DockerConfiguration seIncludeAttributes(List<MesosAttribute> seIncludeAttributes) {
    this.seIncludeAttributes = seIncludeAttributes;
    return this;
  }

  public DockerConfiguration addSeIncludeAttributesItem(MesosAttribute seIncludeAttributesItem) {
    if (this.seIncludeAttributes == null) {
      this.seIncludeAttributes = new ArrayList<MesosAttribute>();
    }
    this.seIncludeAttributes.add(seIncludeAttributesItem);
    return this;
  }

   /**
   * Create SEs just on hosts with include attributes.
   * @return seIncludeAttributes
  **/
  @Schema(description = "Create SEs just on hosts with include attributes.")
  public List<MesosAttribute> getSeIncludeAttributes() {
    return seIncludeAttributes;
  }

  public void setSeIncludeAttributes(List<MesosAttribute> seIncludeAttributes) {
    this.seIncludeAttributes = seIncludeAttributes;
  }

  public DockerConfiguration seSpawnRate(Integer seSpawnRate) {
    this.seSpawnRate = seSpawnRate;
    return this;
  }

   /**
   * New SE spawn rate per minute.
   * @return seSpawnRate
  **/
  @Schema(description = "New SE spawn rate per minute.")
  public Integer getSeSpawnRate() {
    return seSpawnRate;
  }

  public void setSeSpawnRate(Integer seSpawnRate) {
    this.seSpawnRate = seSpawnRate;
  }

  public DockerConfiguration seVolume(String seVolume) {
    this.seVolume = seVolume;
    return this;
  }

   /**
   * Host volume to be used as a disk for Avi SE, This is a disruptive change.
   * @return seVolume
  **/
  @Schema(description = "Host volume to be used as a disk for Avi SE, This is a disruptive change.")
  public String getSeVolume() {
    return seVolume;
  }

  public void setSeVolume(String seVolume) {
    this.seVolume = seVolume;
  }

  public DockerConfiguration servicesAccessibleAllInterfaces(Boolean servicesAccessibleAllInterfaces) {
    this.servicesAccessibleAllInterfaces = servicesAccessibleAllInterfaces;
    return this;
  }

   /**
   * Make service ports accessible on all Host interfaces in addition to East-West VIP and/or bridge IP. Usually enabled AWS clusters to export East-West services on Host interface.
   * @return servicesAccessibleAllInterfaces
  **/
  @Schema(description = "Make service ports accessible on all Host interfaces in addition to East-West VIP and/or bridge IP. Usually enabled AWS clusters to export East-West services on Host interface.")
  public Boolean isServicesAccessibleAllInterfaces() {
    return servicesAccessibleAllInterfaces;
  }

  public void setServicesAccessibleAllInterfaces(Boolean servicesAccessibleAllInterfaces) {
    this.servicesAccessibleAllInterfaces = servicesAccessibleAllInterfaces;
  }

  public DockerConfiguration sshSeDeployment(SSHSeDeployment sshSeDeployment) {
    this.sshSeDeployment = sshSeDeployment;
    return this;
  }

   /**
   * Get sshSeDeployment
   * @return sshSeDeployment
  **/
  @Schema(description = "")
  public SSHSeDeployment getSshSeDeployment() {
    return sshSeDeployment;
  }

  public void setSshSeDeployment(SSHSeDeployment sshSeDeployment) {
    this.sshSeDeployment = sshSeDeployment;
  }

  public DockerConfiguration sshUserRef(String sshUserRef) {
    this.sshUserRef = sshUserRef;
    return this;
  }

   /**
   * Cloud connector user uuid for SSH to hosts. It is a reference to an object of type CloudConnectorUser. Field introduced in 17.1.1.
   * @return sshUserRef
  **/
  @Schema(description = "Cloud connector user uuid for SSH to hosts. It is a reference to an object of type CloudConnectorUser. Field introduced in 17.1.1.")
  public String getSshUserRef() {
    return sshUserRef;
  }

  public void setSshUserRef(String sshUserRef) {
    this.sshUserRef = sshUserRef;
  }

  public DockerConfiguration ucpNodes(List<String> ucpNodes) {
    this.ucpNodes = ucpNodes;
    return this;
  }

  public DockerConfiguration addUcpNodesItem(String ucpNodesItem) {
    if (this.ucpNodes == null) {
      this.ucpNodes = new ArrayList<String>();
    }
    this.ucpNodes.add(ucpNodesItem);
    return this;
  }

   /**
   * List of Docker UCP nodes; In case of a load balanced UCP cluster, use Virtual IP of the cluster.
   * @return ucpNodes
  **/
  @Schema(description = "List of Docker UCP nodes; In case of a load balanced UCP cluster, use Virtual IP of the cluster.")
  public List<String> getUcpNodes() {
    return ucpNodes;
  }

  public void setUcpNodes(List<String> ucpNodes) {
    this.ucpNodes = ucpNodes;
  }

  public DockerConfiguration useContainerIpPort(Boolean useContainerIpPort) {
    this.useContainerIpPort = useContainerIpPort;
    return this;
  }

   /**
   * Use container IP address port for pool instead of host IP address hostport. This mode is applicable if the container IP is reachable (not a private NATed IP) from other hosts in a routed environment for containers.
   * @return useContainerIpPort
  **/
  @Schema(description = "Use container IP address port for pool instead of host IP address hostport. This mode is applicable if the container IP is reachable (not a private NATed IP) from other hosts in a routed environment for containers.")
  public Boolean isUseContainerIpPort() {
    return useContainerIpPort;
  }

  public void setUseContainerIpPort(Boolean useContainerIpPort) {
    this.useContainerIpPort = useContainerIpPort;
  }

  public DockerConfiguration useControllerImage(Boolean useControllerImage) {
    this.useControllerImage = useControllerImage;
    return this;
  }

   /**
   * If true, use controller generated SE docker image via fileservice, else use docker repository image as defined by docker_registry_se.
   * @return useControllerImage
  **/
  @Schema(description = "If true, use controller generated SE docker image via fileservice, else use docker repository image as defined by docker_registry_se.")
  public Boolean isUseControllerImage() {
    return useControllerImage;
  }

  public void setUseControllerImage(Boolean useControllerImage) {
    this.useControllerImage = useControllerImage;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DockerConfiguration dockerConfiguration = (DockerConfiguration) o;
    return Objects.equals(this.appSyncFrequency, dockerConfiguration.appSyncFrequency) &&
        Objects.equals(this.caTlsKeyAndCertificateRef, dockerConfiguration.caTlsKeyAndCertificateRef) &&
        Objects.equals(this.clientTlsKeyAndCertificateRef, dockerConfiguration.clientTlsKeyAndCertificateRef) &&
        Objects.equals(this.containerPortMatchHttpService, dockerConfiguration.containerPortMatchHttpService) &&
        Objects.equals(this.coredumpDirectory, dockerConfiguration.coredumpDirectory) &&
        Objects.equals(this.disableAutoBackendServiceSync, dockerConfiguration.disableAutoBackendServiceSync) &&
        Objects.equals(this.disableAutoFrontendServiceSync, dockerConfiguration.disableAutoFrontendServiceSync) &&
        Objects.equals(this.disableAutoSeCreation, dockerConfiguration.disableAutoSeCreation) &&
        Objects.equals(this.dockerRegistrySe, dockerConfiguration.dockerRegistrySe) &&
        Objects.equals(this.eastWestPlacementSubnet, dockerConfiguration.eastWestPlacementSubnet) &&
        Objects.equals(this.enableEventSubscription, dockerConfiguration.enableEventSubscription) &&
        Objects.equals(this.feproxyContainerPortAsService, dockerConfiguration.feproxyContainerPortAsService) &&
        Objects.equals(this.feproxyVipsEnableProxyArp, dockerConfiguration.feproxyVipsEnableProxyArp) &&
        Objects.equals(this.fleetEndpoint, dockerConfiguration.fleetEndpoint) &&
        Objects.equals(this.httpContainerPorts, dockerConfiguration.httpContainerPorts) &&
        Objects.equals(this.seDeploymentMethod, dockerConfiguration.seDeploymentMethod) &&
        Objects.equals(this.seExcludeAttributes, dockerConfiguration.seExcludeAttributes) &&
        Objects.equals(this.seIncludeAttributes, dockerConfiguration.seIncludeAttributes) &&
        Objects.equals(this.seSpawnRate, dockerConfiguration.seSpawnRate) &&
        Objects.equals(this.seVolume, dockerConfiguration.seVolume) &&
        Objects.equals(this.servicesAccessibleAllInterfaces, dockerConfiguration.servicesAccessibleAllInterfaces) &&
        Objects.equals(this.sshSeDeployment, dockerConfiguration.sshSeDeployment) &&
        Objects.equals(this.sshUserRef, dockerConfiguration.sshUserRef) &&
        Objects.equals(this.ucpNodes, dockerConfiguration.ucpNodes) &&
        Objects.equals(this.useContainerIpPort, dockerConfiguration.useContainerIpPort) &&
        Objects.equals(this.useControllerImage, dockerConfiguration.useControllerImage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(appSyncFrequency, caTlsKeyAndCertificateRef, clientTlsKeyAndCertificateRef, containerPortMatchHttpService, coredumpDirectory, disableAutoBackendServiceSync, disableAutoFrontendServiceSync, disableAutoSeCreation, dockerRegistrySe, eastWestPlacementSubnet, enableEventSubscription, feproxyContainerPortAsService, feproxyVipsEnableProxyArp, fleetEndpoint, httpContainerPorts, seDeploymentMethod, seExcludeAttributes, seIncludeAttributes, seSpawnRate, seVolume, servicesAccessibleAllInterfaces, sshSeDeployment, sshUserRef, ucpNodes, useContainerIpPort, useControllerImage);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DockerConfiguration {\n");
    
    sb.append("    appSyncFrequency: ").append(toIndentedString(appSyncFrequency)).append("\n");
    sb.append("    caTlsKeyAndCertificateRef: ").append(toIndentedString(caTlsKeyAndCertificateRef)).append("\n");
    sb.append("    clientTlsKeyAndCertificateRef: ").append(toIndentedString(clientTlsKeyAndCertificateRef)).append("\n");
    sb.append("    containerPortMatchHttpService: ").append(toIndentedString(containerPortMatchHttpService)).append("\n");
    sb.append("    coredumpDirectory: ").append(toIndentedString(coredumpDirectory)).append("\n");
    sb.append("    disableAutoBackendServiceSync: ").append(toIndentedString(disableAutoBackendServiceSync)).append("\n");
    sb.append("    disableAutoFrontendServiceSync: ").append(toIndentedString(disableAutoFrontendServiceSync)).append("\n");
    sb.append("    disableAutoSeCreation: ").append(toIndentedString(disableAutoSeCreation)).append("\n");
    sb.append("    dockerRegistrySe: ").append(toIndentedString(dockerRegistrySe)).append("\n");
    sb.append("    eastWestPlacementSubnet: ").append(toIndentedString(eastWestPlacementSubnet)).append("\n");
    sb.append("    enableEventSubscription: ").append(toIndentedString(enableEventSubscription)).append("\n");
    sb.append("    feproxyContainerPortAsService: ").append(toIndentedString(feproxyContainerPortAsService)).append("\n");
    sb.append("    feproxyVipsEnableProxyArp: ").append(toIndentedString(feproxyVipsEnableProxyArp)).append("\n");
    sb.append("    fleetEndpoint: ").append(toIndentedString(fleetEndpoint)).append("\n");
    sb.append("    httpContainerPorts: ").append(toIndentedString(httpContainerPorts)).append("\n");
    sb.append("    seDeploymentMethod: ").append(toIndentedString(seDeploymentMethod)).append("\n");
    sb.append("    seExcludeAttributes: ").append(toIndentedString(seExcludeAttributes)).append("\n");
    sb.append("    seIncludeAttributes: ").append(toIndentedString(seIncludeAttributes)).append("\n");
    sb.append("    seSpawnRate: ").append(toIndentedString(seSpawnRate)).append("\n");
    sb.append("    seVolume: ").append(toIndentedString(seVolume)).append("\n");
    sb.append("    servicesAccessibleAllInterfaces: ").append(toIndentedString(servicesAccessibleAllInterfaces)).append("\n");
    sb.append("    sshSeDeployment: ").append(toIndentedString(sshSeDeployment)).append("\n");
    sb.append("    sshUserRef: ").append(toIndentedString(sshUserRef)).append("\n");
    sb.append("    ucpNodes: ").append(toIndentedString(ucpNodes)).append("\n");
    sb.append("    useContainerIpPort: ").append(toIndentedString(useContainerIpPort)).append("\n");
    sb.append("    useControllerImage: ").append(toIndentedString(useControllerImage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
