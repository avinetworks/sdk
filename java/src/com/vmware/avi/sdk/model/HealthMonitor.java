/*
 * Avi avi_global_spec Object API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 20.1.1
 * Contact: support@avinetworks.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.vmware.avi.sdk.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.vmware.avi.sdk.model.HealthMonitorAuthInfo;
import com.vmware.avi.sdk.model.HealthMonitorDNS;
import com.vmware.avi.sdk.model.HealthMonitorExternal;
import com.vmware.avi.sdk.model.HealthMonitorHttp;
import com.vmware.avi.sdk.model.HealthMonitorRadius;
import com.vmware.avi.sdk.model.HealthMonitorSIP;
import com.vmware.avi.sdk.model.HealthMonitorTcp;
import com.vmware.avi.sdk.model.HealthMonitorUdp;
import io.swagger.v3.oas.annotations.media.Schema;
/**
 * HealthMonitor
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-03-12T12:27:26.755+05:30[Asia/Kolkata]")
public class HealthMonitor {
  @JsonProperty("_last_modified")
  private String _lastModified = null;

  @JsonProperty("allow_duplicate_monitors")
  private Boolean allowDuplicateMonitors = null;

  @JsonProperty("authentication")
  private HealthMonitorAuthInfo authentication = null;

  @JsonProperty("description")
  private String description = null;

  @JsonProperty("disable_quickstart")
  private Boolean disableQuickstart = null;

  @JsonProperty("dns_monitor")
  private HealthMonitorDNS dnsMonitor = null;

  @JsonProperty("external_monitor")
  private HealthMonitorExternal externalMonitor = null;

  @JsonProperty("failed_checks")
  private Integer failedChecks = 2;

  @JsonProperty("http_monitor")
  private HealthMonitorHttp httpMonitor = null;

  @JsonProperty("https_monitor")
  private HealthMonitorHttp httpsMonitor = null;

  @JsonProperty("is_federated")
  private Boolean isFederated = null;

  @JsonProperty("monitor_port")
  private Integer monitorPort = null;

  @JsonProperty("name")
  private String name = null;

  @JsonProperty("radius_monitor")
  private HealthMonitorRadius radiusMonitor = null;

  @JsonProperty("receive_timeout")
  private Integer receiveTimeout = 4;

  @JsonProperty("send_interval")
  private Integer sendInterval = 10;

  @JsonProperty("sip_monitor")
  private HealthMonitorSIP sipMonitor = null;

  @JsonProperty("successful_checks")
  private Integer successfulChecks = 2;

  @JsonProperty("tcp_monitor")
  private HealthMonitorTcp tcpMonitor = null;

  @JsonProperty("tenant_ref")
  private String tenantRef = null;

  @JsonProperty("type")
  private String type = null;

  @JsonProperty("udp_monitor")
  private HealthMonitorUdp udpMonitor = null;

  @JsonProperty("url")
  private String url = null;

  @JsonProperty("uuid")
  private String uuid = null;

   /**
   * UNIX time since epoch in microseconds. Units(MICROSECONDS).
   * @return _lastModified
  **/
  @Schema(description = "UNIX time since epoch in microseconds. Units(MICROSECONDS).")
  public String getLastModified() {
    return _lastModified;
  }

  public HealthMonitor allowDuplicateMonitors(Boolean allowDuplicateMonitors) {
    this.allowDuplicateMonitors = allowDuplicateMonitors;
    return this;
  }

   /**
   * By default, multiple instances of the same healthmonitor to the same server are suppressed intelligently. In rare cases, the monitor may have specific constructs that go beyond the server keys (ip, port, etc.) during which such suppression is not desired. Use this knob to allow duplicates. Field introduced in 18.2.8.
   * @return allowDuplicateMonitors
  **/
  @Schema(description = "By default, multiple instances of the same healthmonitor to the same server are suppressed intelligently. In rare cases, the monitor may have specific constructs that go beyond the server keys (ip, port, etc.) during which such suppression is not desired. Use this knob to allow duplicates. Field introduced in 18.2.8.")
  public Boolean isAllowDuplicateMonitors() {
    return allowDuplicateMonitors;
  }

  public void setAllowDuplicateMonitors(Boolean allowDuplicateMonitors) {
    this.allowDuplicateMonitors = allowDuplicateMonitors;
  }

  public HealthMonitor authentication(HealthMonitorAuthInfo authentication) {
    this.authentication = authentication;
    return this;
  }

   /**
   * Get authentication
   * @return authentication
  **/
  @Schema(description = "")
  public HealthMonitorAuthInfo getAuthentication() {
    return authentication;
  }

  public void setAuthentication(HealthMonitorAuthInfo authentication) {
    this.authentication = authentication;
  }

  public HealthMonitor description(String description) {
    this.description = description;
    return this;
  }

   /**
   * User defined description for the object.
   * @return description
  **/
  @Schema(description = "User defined description for the object.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public HealthMonitor disableQuickstart(Boolean disableQuickstart) {
    this.disableQuickstart = disableQuickstart;
    return this;
  }

   /**
   * During addition of a server or healthmonitors or during bootup, Avi performs sequential health checks rather than waiting for send-interval to kick in, to mark the server up as soon as possible. This knob may be used to turn this feature off. Field introduced in 18.2.7.
   * @return disableQuickstart
  **/
  @Schema(description = "During addition of a server or healthmonitors or during bootup, Avi performs sequential health checks rather than waiting for send-interval to kick in, to mark the server up as soon as possible. This knob may be used to turn this feature off. Field introduced in 18.2.7.")
  public Boolean isDisableQuickstart() {
    return disableQuickstart;
  }

  public void setDisableQuickstart(Boolean disableQuickstart) {
    this.disableQuickstart = disableQuickstart;
  }

  public HealthMonitor dnsMonitor(HealthMonitorDNS dnsMonitor) {
    this.dnsMonitor = dnsMonitor;
    return this;
  }

   /**
   * Get dnsMonitor
   * @return dnsMonitor
  **/
  @Schema(description = "")
  public HealthMonitorDNS getDnsMonitor() {
    return dnsMonitor;
  }

  public void setDnsMonitor(HealthMonitorDNS dnsMonitor) {
    this.dnsMonitor = dnsMonitor;
  }

  public HealthMonitor externalMonitor(HealthMonitorExternal externalMonitor) {
    this.externalMonitor = externalMonitor;
    return this;
  }

   /**
   * Get externalMonitor
   * @return externalMonitor
  **/
  @Schema(description = "")
  public HealthMonitorExternal getExternalMonitor() {
    return externalMonitor;
  }

  public void setExternalMonitor(HealthMonitorExternal externalMonitor) {
    this.externalMonitor = externalMonitor;
  }

  public HealthMonitor failedChecks(Integer failedChecks) {
    this.failedChecks = failedChecks;
    return this;
  }

   /**
   * Number of continuous failed health checks before the server is marked down. Allowed values are 1-50.
   * @return failedChecks
  **/
  @Schema(description = "Number of continuous failed health checks before the server is marked down. Allowed values are 1-50.")
  public Integer getFailedChecks() {
    return failedChecks;
  }

  public void setFailedChecks(Integer failedChecks) {
    this.failedChecks = failedChecks;
  }

  public HealthMonitor httpMonitor(HealthMonitorHttp httpMonitor) {
    this.httpMonitor = httpMonitor;
    return this;
  }

   /**
   * Get httpMonitor
   * @return httpMonitor
  **/
  @Schema(description = "")
  public HealthMonitorHttp getHttpMonitor() {
    return httpMonitor;
  }

  public void setHttpMonitor(HealthMonitorHttp httpMonitor) {
    this.httpMonitor = httpMonitor;
  }

  public HealthMonitor httpsMonitor(HealthMonitorHttp httpsMonitor) {
    this.httpsMonitor = httpsMonitor;
    return this;
  }

   /**
   * Get httpsMonitor
   * @return httpsMonitor
  **/
  @Schema(description = "")
  public HealthMonitorHttp getHttpsMonitor() {
    return httpsMonitor;
  }

  public void setHttpsMonitor(HealthMonitorHttp httpsMonitor) {
    this.httpsMonitor = httpsMonitor;
  }

  public HealthMonitor isFederated(Boolean isFederated) {
    this.isFederated = isFederated;
    return this;
  }

   /**
   * This field describes the object&#x27;s replication scope. If the field is set to false, then the object is visible within the controller-cluster and its associated service-engines.  If the field is set to true, then the object is replicated across the federation.  . Field introduced in 17.1.3.
   * @return isFederated
  **/
  @Schema(description = "This field describes the object's replication scope. If the field is set to false, then the object is visible within the controller-cluster and its associated service-engines.  If the field is set to true, then the object is replicated across the federation.  . Field introduced in 17.1.3.")
  public Boolean isIsFederated() {
    return isFederated;
  }

  public void setIsFederated(Boolean isFederated) {
    this.isFederated = isFederated;
  }

  public HealthMonitor monitorPort(Integer monitorPort) {
    this.monitorPort = monitorPort;
    return this;
  }

   /**
   * Use this port instead of the port defined for the server in the Pool. If the monitor succeeds to this port, the load balanced traffic will still be sent to the port of the server defined within the Pool. Allowed values are 1-65535. Special values are 0 - &#x27;Use server port&#x27;.
   * @return monitorPort
  **/
  @Schema(description = "Use this port instead of the port defined for the server in the Pool. If the monitor succeeds to this port, the load balanced traffic will still be sent to the port of the server defined within the Pool. Allowed values are 1-65535. Special values are 0 - 'Use server port'.")
  public Integer getMonitorPort() {
    return monitorPort;
  }

  public void setMonitorPort(Integer monitorPort) {
    this.monitorPort = monitorPort;
  }

  public HealthMonitor name(String name) {
    this.name = name;
    return this;
  }

   /**
   * A user friendly name for this health monitor.
   * @return name
  **/
  @Schema(required = true, description = "A user friendly name for this health monitor.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public HealthMonitor radiusMonitor(HealthMonitorRadius radiusMonitor) {
    this.radiusMonitor = radiusMonitor;
    return this;
  }

   /**
   * Get radiusMonitor
   * @return radiusMonitor
  **/
  @Schema(description = "")
  public HealthMonitorRadius getRadiusMonitor() {
    return radiusMonitor;
  }

  public void setRadiusMonitor(HealthMonitorRadius radiusMonitor) {
    this.radiusMonitor = radiusMonitor;
  }

  public HealthMonitor receiveTimeout(Integer receiveTimeout) {
    this.receiveTimeout = receiveTimeout;
    return this;
  }

   /**
   * A valid response from the server is expected within the receive timeout window.  This timeout must be less than the send interval.  If server status is regularly flapping up and down, consider increasing this value. Allowed values are 1-2400.
   * @return receiveTimeout
  **/
  @Schema(description = "A valid response from the server is expected within the receive timeout window.  This timeout must be less than the send interval.  If server status is regularly flapping up and down, consider increasing this value. Allowed values are 1-2400.")
  public Integer getReceiveTimeout() {
    return receiveTimeout;
  }

  public void setReceiveTimeout(Integer receiveTimeout) {
    this.receiveTimeout = receiveTimeout;
  }

  public HealthMonitor sendInterval(Integer sendInterval) {
    this.sendInterval = sendInterval;
    return this;
  }

   /**
   * Frequency, in seconds, that monitors are sent to a server. Allowed values are 1-3600.
   * @return sendInterval
  **/
  @Schema(description = "Frequency, in seconds, that monitors are sent to a server. Allowed values are 1-3600.")
  public Integer getSendInterval() {
    return sendInterval;
  }

  public void setSendInterval(Integer sendInterval) {
    this.sendInterval = sendInterval;
  }

  public HealthMonitor sipMonitor(HealthMonitorSIP sipMonitor) {
    this.sipMonitor = sipMonitor;
    return this;
  }

   /**
   * Get sipMonitor
   * @return sipMonitor
  **/
  @Schema(description = "")
  public HealthMonitorSIP getSipMonitor() {
    return sipMonitor;
  }

  public void setSipMonitor(HealthMonitorSIP sipMonitor) {
    this.sipMonitor = sipMonitor;
  }

  public HealthMonitor successfulChecks(Integer successfulChecks) {
    this.successfulChecks = successfulChecks;
    return this;
  }

   /**
   * Number of continuous successful health checks before server is marked up. Allowed values are 1-50.
   * @return successfulChecks
  **/
  @Schema(description = "Number of continuous successful health checks before server is marked up. Allowed values are 1-50.")
  public Integer getSuccessfulChecks() {
    return successfulChecks;
  }

  public void setSuccessfulChecks(Integer successfulChecks) {
    this.successfulChecks = successfulChecks;
  }

  public HealthMonitor tcpMonitor(HealthMonitorTcp tcpMonitor) {
    this.tcpMonitor = tcpMonitor;
    return this;
  }

   /**
   * Get tcpMonitor
   * @return tcpMonitor
  **/
  @Schema(description = "")
  public HealthMonitorTcp getTcpMonitor() {
    return tcpMonitor;
  }

  public void setTcpMonitor(HealthMonitorTcp tcpMonitor) {
    this.tcpMonitor = tcpMonitor;
  }

  public HealthMonitor tenantRef(String tenantRef) {
    this.tenantRef = tenantRef;
    return this;
  }

   /**
   *  It is a reference to an object of type Tenant.
   * @return tenantRef
  **/
  @Schema(description = " It is a reference to an object of type Tenant.")
  public String getTenantRef() {
    return tenantRef;
  }

  public void setTenantRef(String tenantRef) {
    this.tenantRef = tenantRef;
  }

  public HealthMonitor type(String type) {
    this.type = type;
    return this;
  }

   /**
   * Type of the health monitor. Enum options - HEALTH_MONITOR_PING, HEALTH_MONITOR_TCP, HEALTH_MONITOR_HTTP, HEALTH_MONITOR_HTTPS, HEALTH_MONITOR_EXTERNAL, HEALTH_MONITOR_UDP, HEALTH_MONITOR_DNS, HEALTH_MONITOR_GSLB, HEALTH_MONITOR_SIP, HEALTH_MONITOR_RADIUS.
   * @return type
  **/
  @Schema(required = true, description = "Type of the health monitor. Enum options - HEALTH_MONITOR_PING, HEALTH_MONITOR_TCP, HEALTH_MONITOR_HTTP, HEALTH_MONITOR_HTTPS, HEALTH_MONITOR_EXTERNAL, HEALTH_MONITOR_UDP, HEALTH_MONITOR_DNS, HEALTH_MONITOR_GSLB, HEALTH_MONITOR_SIP, HEALTH_MONITOR_RADIUS.")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public HealthMonitor udpMonitor(HealthMonitorUdp udpMonitor) {
    this.udpMonitor = udpMonitor;
    return this;
  }

   /**
   * Get udpMonitor
   * @return udpMonitor
  **/
  @Schema(description = "")
  public HealthMonitorUdp getUdpMonitor() {
    return udpMonitor;
  }

  public void setUdpMonitor(HealthMonitorUdp udpMonitor) {
    this.udpMonitor = udpMonitor;
  }

   /**
   * url
   * @return url
  **/
  @Schema(description = "url")
  public String getUrl() {
    return url;
  }

  public HealthMonitor uuid(String uuid) {
    this.uuid = uuid;
    return this;
  }

   /**
   * UUID of the health monitor.
   * @return uuid
  **/
  @Schema(description = "UUID of the health monitor.")
  public String getUuid() {
    return uuid;
  }

  public void setUuid(String uuid) {
    this.uuid = uuid;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    HealthMonitor healthMonitor = (HealthMonitor) o;
    return Objects.equals(this._lastModified, healthMonitor._lastModified) &&
        Objects.equals(this.allowDuplicateMonitors, healthMonitor.allowDuplicateMonitors) &&
        Objects.equals(this.authentication, healthMonitor.authentication) &&
        Objects.equals(this.description, healthMonitor.description) &&
        Objects.equals(this.disableQuickstart, healthMonitor.disableQuickstart) &&
        Objects.equals(this.dnsMonitor, healthMonitor.dnsMonitor) &&
        Objects.equals(this.externalMonitor, healthMonitor.externalMonitor) &&
        Objects.equals(this.failedChecks, healthMonitor.failedChecks) &&
        Objects.equals(this.httpMonitor, healthMonitor.httpMonitor) &&
        Objects.equals(this.httpsMonitor, healthMonitor.httpsMonitor) &&
        Objects.equals(this.isFederated, healthMonitor.isFederated) &&
        Objects.equals(this.monitorPort, healthMonitor.monitorPort) &&
        Objects.equals(this.name, healthMonitor.name) &&
        Objects.equals(this.radiusMonitor, healthMonitor.radiusMonitor) &&
        Objects.equals(this.receiveTimeout, healthMonitor.receiveTimeout) &&
        Objects.equals(this.sendInterval, healthMonitor.sendInterval) &&
        Objects.equals(this.sipMonitor, healthMonitor.sipMonitor) &&
        Objects.equals(this.successfulChecks, healthMonitor.successfulChecks) &&
        Objects.equals(this.tcpMonitor, healthMonitor.tcpMonitor) &&
        Objects.equals(this.tenantRef, healthMonitor.tenantRef) &&
        Objects.equals(this.type, healthMonitor.type) &&
        Objects.equals(this.udpMonitor, healthMonitor.udpMonitor) &&
        Objects.equals(this.url, healthMonitor.url) &&
        Objects.equals(this.uuid, healthMonitor.uuid);
  }

  @Override
  public int hashCode() {
    return Objects.hash(_lastModified, allowDuplicateMonitors, authentication, description, disableQuickstart, dnsMonitor, externalMonitor, failedChecks, httpMonitor, httpsMonitor, isFederated, monitorPort, name, radiusMonitor, receiveTimeout, sendInterval, sipMonitor, successfulChecks, tcpMonitor, tenantRef, type, udpMonitor, url, uuid);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class HealthMonitor {\n");
    
    sb.append("    _lastModified: ").append(toIndentedString(_lastModified)).append("\n");
    sb.append("    allowDuplicateMonitors: ").append(toIndentedString(allowDuplicateMonitors)).append("\n");
    sb.append("    authentication: ").append(toIndentedString(authentication)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    disableQuickstart: ").append(toIndentedString(disableQuickstart)).append("\n");
    sb.append("    dnsMonitor: ").append(toIndentedString(dnsMonitor)).append("\n");
    sb.append("    externalMonitor: ").append(toIndentedString(externalMonitor)).append("\n");
    sb.append("    failedChecks: ").append(toIndentedString(failedChecks)).append("\n");
    sb.append("    httpMonitor: ").append(toIndentedString(httpMonitor)).append("\n");
    sb.append("    httpsMonitor: ").append(toIndentedString(httpsMonitor)).append("\n");
    sb.append("    isFederated: ").append(toIndentedString(isFederated)).append("\n");
    sb.append("    monitorPort: ").append(toIndentedString(monitorPort)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    radiusMonitor: ").append(toIndentedString(radiusMonitor)).append("\n");
    sb.append("    receiveTimeout: ").append(toIndentedString(receiveTimeout)).append("\n");
    sb.append("    sendInterval: ").append(toIndentedString(sendInterval)).append("\n");
    sb.append("    sipMonitor: ").append(toIndentedString(sipMonitor)).append("\n");
    sb.append("    successfulChecks: ").append(toIndentedString(successfulChecks)).append("\n");
    sb.append("    tcpMonitor: ").append(toIndentedString(tcpMonitor)).append("\n");
    sb.append("    tenantRef: ").append(toIndentedString(tenantRef)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    udpMonitor: ").append(toIndentedString(udpMonitor)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    uuid: ").append(toIndentedString(uuid)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
