#!/usr/bin/perl -w
###############################################################################
#                                                                             #
# F5 Networks and BIG/ip(c) Copyright                                         #
#                                                                             #
# No part of the software may be reproduced or transmitted in any form or by  #
# any means, electronic or mechanical, for any purpose, without express       #
# written permission of F5 Networks, Inc. It is against the law to copy the   #
# software. No part of this program may be reproduced or transmitted in any   #
# form or by any means, electronic or mechanical, including photocopying,     #
# recording, or information storage and retrieval systems, for any purpose    #
# other than the purchasers personal use, without the express written         #
# permission of F5 Networks, Inc. Copyright (c) 1996-2005, 2012-2013 BIG/ip Software. All     #
# rights reserved. Our services are only available for legal users of the     #
# program for instance in case we extend our services by offering updating of #
# files through Internet.                                                     #
#                                                                             #
###############################################################################
#
# This program writes its command line arguments and its
# environment to a file.
#
# As for any external monitor program, the first two command
# line arguments are the node ip address and the node port.
# After that its whatever is supplied via the monitor template.
#

use strict;
require 5.005;

# Derive and untaint programname.
my $programname = '/' . $0;
$programname =~ m/^.*\/([^\/]+)$/;
$programname = $1;

if ($programname eq '') {
    die "Bad data in program name\n"
}

# Process ID and file where it's to be stored.  The format
# is significant.

my $node = $ENV{"NODE_IP"};
my $port = $ENV{"NODE_PORT"};

my $pidfile = "/var/run/$programname.$node..$port.pid";
my $pid = "$$";

# Maintenence.  Clean up any existing EAV.

if (-f $pidfile ) {
    open(PID, "<$pidfile"); 
    my $pid = <PID>; 
    close(PID);
    if ( $pid ) {
        chomp $pid; $pid =~ m/^(\d+)$/; $pid = $1;
        if ( $pid ) {
            kill 9, $pid;
        }
    }
    unlink($pidfile);
}

# Create a new maintenence file.

open(PID, ">$pidfile");
print PID $pid, "\n";
close(PID);

# Open the output file

my $outfile = "/var/arg_ex_out";

open( OUTF, ">>$outfile" );

# Print the command line args

my $cmdlinearg = 0;

print OUTF "---- Command Line Args ----\n";

while( $cmdlinearg = shift @ARGV ) {
   print OUTF $cmdlinearg, "\n";
}

my $key;

# Print the environment

print OUTF "---- Environment Args ----\n";

foreach $key (sort keys %ENV) {
   printf OUTF "$key=$ENV{$key}\n"
}

print OUTF "---- End Args ----\n";

close( OUTF );

# Unlink the pidfile before echoing anything to stdout      
# as bigd stops the script as soon anything is output to stdout.        
unlink($pidfile);       

# Arbitrarily tell bigd that the node is up.
print "up\n";

exit(0);
